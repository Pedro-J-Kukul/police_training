
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Pedro-J-Kukul/police_training/cmd/api/context.go (50.0%)</option>
				
				<option value="file1">github.com/Pedro-J-Kukul/police_training/cmd/api/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/Pedro-J-Kukul/police_training/cmd/api/errors.go (38.2%)</option>
				
				<option value="file3">github.com/Pedro-J-Kukul/police_training/cmd/api/healthcheck.go (0.0%)</option>
				
				<option value="file4">github.com/Pedro-J-Kukul/police_training/cmd/api/helpers.go (59.5%)</option>
				
				<option value="file5">github.com/Pedro-J-Kukul/police_training/cmd/api/main.go (0.0%)</option>
				
				<option value="file6">github.com/Pedro-J-Kukul/police_training/cmd/api/middleware.go (0.0%)</option>
				
				<option value="file7">github.com/Pedro-J-Kukul/police_training/cmd/api/officers.go (71.3%)</option>
				
				<option value="file8">github.com/Pedro-J-Kukul/police_training/cmd/api/reference_data.go (0.4%)</option>
				
				<option value="file9">github.com/Pedro-J-Kukul/police_training/cmd/api/routes.go (0.0%)</option>
				
				<option value="file10">github.com/Pedro-J-Kukul/police_training/cmd/api/server.go (0.0%)</option>
				
				<option value="file11">github.com/Pedro-J-Kukul/police_training/cmd/api/test_helpers.go (100.0%)</option>
				
				<option value="file12">github.com/Pedro-J-Kukul/police_training/cmd/api/tokens.go (57.0%)</option>
				
				<option value="file13">github.com/Pedro-J-Kukul/police_training/cmd/api/training_enrollments.go (70.5%)</option>
				
				<option value="file14">github.com/Pedro-J-Kukul/police_training/cmd/api/training_sessions.go (64.2%)</option>
				
				<option value="file15">github.com/Pedro-J-Kukul/police_training/cmd/api/users.go (63.6%)</option>
				
				<option value="file16">github.com/Pedro-J-Kukul/police_training/cmd/api/workshops.go (76.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// FileName: internal/data/context.go
package main

import (
        "context"
        "net/http"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
)

type contextKey string // Define a custom type for context keys to avoid collisions

const contextKeyUser = contextKey("user") // Key for storing/retrieving user information in/from context

// contextSetUser adds the user information to the request context.
func (app *appDependencies) contextSetUser(r *http.Request, user *data.User) *http.Request <span class="cov0" title="0">{
        ctx := context.WithValue(r.Context(), contextKeyUser, user) // Add user to context
        return r.WithContext(ctx)                                   // Return a new request with the updated context
}</span>

// contextGetUser retrieves the user information from the request context.
func (app *appDependencies) contextGetUser(r *http.Request) *data.User <span class="cov8" title="1">{
        user, ok := r.Context().Value(contextKeyUser).(*data.User) // Retrieve user from context
        if !ok </span><span class="cov0" title="0">{
                panic("missing user value in context")</span> // Panic if user is not found in context
        }
        <span class="cov8" title="1">return user</span> // Return the retrieved user
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/v1/attendance/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of attendance statuses with optional filtering",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attendance-statuses"
                ],
                "summary": "List attendance statuses",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by status name",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "description": "Filter by counts as present flag",
                        "name": "counts_as_present",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new attendance status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attendance-statuses"
                ],
                "summary": "Create a new attendance status",
                "parameters": [
                    {
                        "description": "Attendance status data",
                        "name": "attendance_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateAttendanceStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/attendance/status/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve an attendance status by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attendance-statuses"
                ],
                "summary": "Get an attendance status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attendance status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on an attendance status record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attendance-statuses"
                ],
                "summary": "Update an attendance status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attendance status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Attendance status data",
                        "name": "attendance_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateAttendanceStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/enrollment/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of enrollment statuses with optional filtering by status name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollment-statuses"
                ],
                "summary": "List enrollment statuses",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by status name",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new enrollment status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollment-statuses"
                ],
                "summary": "Create a new enrollment status",
                "parameters": [
                    {
                        "description": "Enrollment status data",
                        "name": "enrollment_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateEnrollmentStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/enrollment/status/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve an enrollment status by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollment-statuses"
                ],
                "summary": "Get an enrollment status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Enrollment status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on an enrollment status record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollment-statuses"
                ],
                "summary": "Update an enrollment status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Enrollment status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Enrollment status data",
                        "name": "enrollment_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateEnrollmentStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/formations": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of formations with optional filtering by name and region",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "formations"
                ],
                "summary": "List formations",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by formation name",
                        "name": "formation",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by region ID",
                        "name": "region_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new formation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "formations"
                ],
                "summary": "Create a new formation",
                "parameters": [
                    {
                        "description": "Formation data",
                        "name": "formation",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateFormationRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/formations/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a formation by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "formations"
                ],
                "summary": "Get a formation",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Formation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a formation record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "formations"
                ],
                "summary": "Update a formation",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Formation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Formation data",
                        "name": "formation",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateFormationRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/me": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve the user record associated with the current request context",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get current user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/officers": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of officers with optional filtering by regulation number, posting, rank, formation, and region",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "officers"
                ],
                "summary": "List officers",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by regulation number",
                        "name": "regulation_number",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by posting ID",
                        "name": "posting_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by rank ID",
                        "name": "rank_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by formation ID",
                        "name": "formation_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by region ID",
                        "name": "region_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new officer",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "officers"
                ],
                "summary": "Create a new officer",
                "parameters": [
                    {
                        "description": "Officer data",
                        "name": "officer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateOfficerRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/officers/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve an officer by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "officers"
                ],
                "summary": "Get an officer",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Officer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete an officer by its ID",
                "tags": [
                    "officers"
                ],
                "summary": "Delete an officer",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Officer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/main.envelope"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "message": {
                                            "type": "string"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on an officer record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "officers"
                ],
                "summary": "Update an officer",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Officer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Officer data",
                        "name": "officer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateOfficerRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/postings": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of postings with optional filtering by name and code",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "postings"
                ],
                "summary": "List postings",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by posting name",
                        "name": "posting",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filter by posting code",
                        "name": "code",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new posting",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "postings"
                ],
                "summary": "Create a new posting",
                "parameters": [
                    {
                        "description": "Posting data",
                        "name": "posting",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreatePostingRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/postings/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a posting by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "postings"
                ],
                "summary": "Get a posting",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Posting ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a posting record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "postings"
                ],
                "summary": "Update a posting",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Posting ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Posting data",
                        "name": "posting",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdatePostingRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/progress/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of progress statuses with optional filtering",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "progress-statuses"
                ],
                "summary": "List progress statuses",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by status name",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new progress status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "progress-statuses"
                ],
                "summary": "Create a new progress status",
                "parameters": [
                    {
                        "description": "Progress status data",
                        "name": "progress_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateProgressStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/progress/status/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a progress status by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "progress-statuses"
                ],
                "summary": "Get a progress status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Progress status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a progress status record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "progress-statuses"
                ],
                "summary": "Update a progress status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Progress status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Progress status data",
                        "name": "progress_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateProgressStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/ranks": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of ranks with optional filtering by rank name and code",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ranks"
                ],
                "summary": "List ranks",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by rank name",
                        "name": "rank",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filter by rank code",
                        "name": "code",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new rank",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ranks"
                ],
                "summary": "Create a new rank",
                "parameters": [
                    {
                        "description": "Rank data",
                        "name": "rank",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateRankRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/ranks/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a rank by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ranks"
                ],
                "summary": "Get a rank",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Rank ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a rank record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ranks"
                ],
                "summary": "Update a rank",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Rank ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Rank data",
                        "name": "rank",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateRankRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/regions": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of regions with optional filtering",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "regions"
                ],
                "summary": "List regions",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by region name",
                        "name": "region",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new region",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "regions"
                ],
                "summary": "Create a new region",
                "parameters": [
                    {
                        "description": "Region data",
                        "name": "region",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateRegionRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/regions/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a region by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "regions"
                ],
                "summary": "Get a region",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Region ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a region record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "regions"
                ],
                "summary": "Update a region",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Region ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Region data",
                        "name": "region",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateRegionRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/tokens/authentication": {
            "post": {
                "description": "Generates an authentication token for a user based on provided email and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Tokens"
                ],
                "summary": "Create Authentication Token",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateAuthenticationTokenRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/tokens/password-reset": {
            "post": {
                "description": "Generates a password reset token and sends it to the user's email address.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Tokens"
                ],
                "summary": "Create Password Reset Token",
                "parameters": [
                    {
                        "description": "User email",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreatePasswordResetTokenRequest_T"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/categories": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of training categories with optional filtering by name and active status",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-categories"
                ],
                "summary": "List training categories",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by category name",
                        "name": "name",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "description": "Filter by active status",
                        "name": "is_active",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new training category",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-categories"
                ],
                "summary": "Create a new training category",
                "parameters": [
                    {
                        "description": "Training category data",
                        "name": "training_category",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateTrainingCategoryRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/categories/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a training category by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-categories"
                ],
                "summary": "Get a training category",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a training category record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-categories"
                ],
                "summary": "Update a training category",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Training category data",
                        "name": "training_category",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateTrainingCategoryRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/enrollments": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of training enrollments with optional filtering",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-enrollments"
                ],
                "summary": "List training enrollments",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Filter by officer ID",
                        "name": "officer_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by session ID",
                        "name": "session_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by enrollment status ID",
                        "name": "enrollment_status_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by progress status ID",
                        "name": "progress_status_id",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "description": "Filter by certificate issued status",
                        "name": "certificate_issued",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new training enrollment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-enrollments"
                ],
                "summary": "Create a new training enrollment",
                "parameters": [
                    {
                        "description": "Training enrollment data",
                        "name": "training_enrollment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateTrainingEnrollmentRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/enrollments/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a training enrollment by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-enrollments"
                ],
                "summary": "Get a training enrollment",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training enrollment ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete a training enrollment by its ID",
                "tags": [
                    "training-enrollments"
                ],
                "summary": "Delete a training enrollment",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training enrollment ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/main.envelope"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "message": {
                                            "type": "string"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a training enrollment record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-enrollments"
                ],
                "summary": "Update a training enrollment",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training enrollment ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Training enrollment data",
                        "name": "training_enrollment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateTrainingEnrollmentRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/sessions": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of training sessions with optional filtering",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-sessions"
                ],
                "summary": "List training sessions",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Filter by formation ID",
                        "name": "formation_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by region ID",
                        "name": "region_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by facilitator ID",
                        "name": "facilitator_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by workshop ID",
                        "name": "workshop_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by training status ID",
                        "name": "training_status_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filter by location",
                        "name": "location",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filter by notes",
                        "name": "notes",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filter by session date (YYYY-MM-DD)",
                        "name": "session_date",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new training session",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-sessions"
                ],
                "summary": "Create a new training session",
                "parameters": [
                    {
                        "description": "Training session data",
                        "name": "training_session",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateTrainingSessionRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/sessions/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a training session by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-sessions"
                ],
                "summary": "Get a training session",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete a training session by its ID",
                "tags": [
                    "training-sessions"
                ],
                "summary": "Delete a training session",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/main.envelope"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "message": {
                                            "type": "string"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a training session record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-sessions"
                ],
                "summary": "Update a training session",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Training session data",
                        "name": "training_session",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateTrainingSessionRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of training statuses with optional filtering by status name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-statuses"
                ],
                "summary": "List training statuses",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by status name",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new training status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-statuses"
                ],
                "summary": "Create a new training status",
                "parameters": [
                    {
                        "description": "Training status data",
                        "name": "training_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateTrainingStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/status/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a training status by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-statuses"
                ],
                "summary": "Get a training status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a training status record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-statuses"
                ],
                "summary": "Update a training status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training status ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Training status data",
                        "name": "training_status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateTrainingStatusRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/types": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of training types with optional filtering by type name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-types"
                ],
                "summary": "List training types",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by training type name",
                        "name": "type",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new training type",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-types"
                ],
                "summary": "Create a new training type",
                "parameters": [
                    {
                        "description": "Training type data",
                        "name": "training_type",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateTrainingTypeRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/training/types/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a training type by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-types"
                ],
                "summary": "Get a training type",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training type ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a training type record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "training-types"
                ],
                "summary": "Update a training type",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Training type ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Training type data",
                        "name": "training_type",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateTrainingTypeRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/users": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of users with optional filters and pagination",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "List users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new user account and send an activation email",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.registerUserRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/users/activate": {
            "put": {
                "description": "Activate a user account using an activation token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Activate a user account",
                "parameters": [
                    {
                        "description": "Activation token",
                        "name": "token",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.activateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/users/password-reset": {
            "put": {
                "description": "Resets a user's password using a valid password reset token.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Tokens"
                ],
                "summary": "Reset Password",
                "parameters": [
                    {
                        "description": "Password reset data",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.ResetPasswordRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/users/{id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete a user record by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete a user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/main.envelope"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "message": {
                                            "type": "string"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a user record",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update a user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/workshops": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a list of workshops with optional filtering by name, category, training type, and active status",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "workshops"
                ],
                "summary": "List workshops",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by workshop name",
                        "name": "workshop_name",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by category ID",
                        "name": "category_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Filter by training type ID",
                        "name": "training_type_id",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "description": "Filter by active status",
                        "name": "is_active",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Page number for pagination",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create a new workshop",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "workshops"
                ],
                "summary": "Create a new workshop",
                "parameters": [
                    {
                        "description": "Workshop data",
                        "name": "workshop",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.CreateWorkshopRequest_T"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        },
        "/v1/workshops/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve a workshop by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "workshops"
                ],
                "summary": "Get a workshop",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Workshop ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Perform a partial update on a workshop record",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "workshops"
                ],
                "summary": "Update a workshop",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Workshop ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Workshop data",
                        "name": "workshop",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/main.UpdateWorkshopRequest_T"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/main.envelope"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/main.errorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "main.CreateAttendanceStatusRequest_T": {
            "type": "object",
            "properties": {
                "counts_as_present": {
                    "type": "boolean"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "main.CreateAuthenticationTokenRequest_T": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "main.CreateEnrollmentStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.CreateFormationRequest_T": {
            "type": "object",
            "properties": {
                "formation": {
                    "type": "string"
                },
                "region_id": {
                    "type": "integer"
                }
            }
        },
        "main.CreateOfficerRequest_T": {
            "type": "object",
            "properties": {
                "formation_id": {
                    "type": "integer"
                },
                "posting_id": {
                    "type": "integer"
                },
                "rank_id": {
                    "type": "integer"
                },
                "region_id": {
                    "type": "integer"
                },
                "regulation_number": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "main.CreatePasswordResetTokenRequest_T": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "main.CreatePostingRequest_T": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "posting": {
                    "type": "string"
                }
            }
        },
        "main.CreateProgressStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.CreateRankRequest_T": {
            "type": "object",
            "properties": {
                "annual_training_hours_required": {
                    "type": "integer"
                },
                "code": {
                    "type": "string"
                },
                "rank": {
                    "type": "string"
                }
            }
        },
        "main.CreateRegionRequest_T": {
            "type": "object",
            "properties": {
                "region": {
                    "type": "string"
                }
            }
        },
        "main.CreateTrainingCategoryRequest_T": {
            "type": "object",
            "properties": {
                "is_active": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "main.CreateTrainingEnrollmentRequest_T": {
            "type": "object",
            "properties": {
                "attendance_status_id": {
                    "type": "integer"
                },
                "certificate_issued": {
                    "type": "boolean"
                },
                "certificate_number": {
                    "type": "string"
                },
                "completion_date": {
                    "description": "Accept as string",
                    "type": "string"
                },
                "enrollment_status_id": {
                    "type": "integer"
                },
                "officer_id": {
                    "type": "integer"
                },
                "progress_status_id": {
                    "type": "integer"
                },
                "session_id": {
                    "type": "integer"
                }
            }
        },
        "main.CreateTrainingSessionRequest_T": {
            "type": "object",
            "properties": {
                "end_time": {
                    "type": "string"
                },
                "facilitator_id": {
                    "type": "integer"
                },
                "formation_id": {
                    "type": "integer"
                },
                "location": {
                    "type": "string"
                },
                "max_capacity": {
                    "type": "integer"
                },
                "notes": {
                    "type": "string"
                },
                "region_id": {
                    "type": "integer"
                },
                "session_date": {
                    "type": "string"
                },
                "start_time": {
                    "type": "string"
                },
                "training_status_id": {
                    "type": "integer"
                },
                "workshop_id": {
                    "type": "integer"
                }
            }
        },
        "main.CreateTrainingStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.CreateTrainingTypeRequest_T": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                }
            }
        },
        "main.CreateWorkshopRequest_T": {
            "type": "object",
            "properties": {
                "category_id": {
                    "type": "integer"
                },
                "credit_hours": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "objectives": {
                    "type": "string"
                },
                "training_type_id": {
                    "type": "integer"
                },
                "workshop_name": {
                    "type": "string"
                }
            }
        },
        "main.ResetPasswordRequest_T": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "main.UpdateAttendanceStatusRequest_T": {
            "type": "object",
            "properties": {
                "counts_as_present": {
                    "type": "boolean"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "main.UpdateEnrollmentStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.UpdateFormationRequest_T": {
            "type": "object",
            "properties": {
                "formation": {
                    "type": "string"
                },
                "region_id": {
                    "type": "integer"
                }
            }
        },
        "main.UpdateOfficerRequest_T": {
            "type": "object",
            "properties": {
                "formation_id": {
                    "type": "integer"
                },
                "posting_id": {
                    "type": "integer"
                },
                "rank_id": {
                    "type": "integer"
                },
                "region_id": {
                    "type": "integer"
                },
                "regulation_number": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "main.UpdatePostingRequest_T": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "posting": {
                    "type": "string"
                }
            }
        },
        "main.UpdateProgressStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.UpdateRankRequest_T": {
            "type": "object",
            "properties": {
                "annual_training_hours_required": {
                    "type": "integer"
                },
                "code": {
                    "type": "string"
                },
                "rank": {
                    "type": "string"
                }
            }
        },
        "main.UpdateRegionRequest_T": {
            "type": "object",
            "properties": {
                "region": {
                    "type": "string"
                }
            }
        },
        "main.UpdateTrainingCategoryRequest_T": {
            "type": "object",
            "properties": {
                "is_active": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "main.UpdateTrainingEnrollmentRequest_T": {
            "type": "object",
            "properties": {
                "attendance_status_id": {
                    "description": "Fixed: was **int64",
                    "type": "integer"
                },
                "certificate_issued": {
                    "type": "boolean"
                },
                "certificate_number": {
                    "type": "string"
                },
                "completion_date": {
                    "type": "string"
                },
                "enrollment_status_id": {
                    "type": "integer"
                },
                "officer_id": {
                    "type": "integer"
                },
                "progress_status_id": {
                    "type": "integer"
                },
                "session_id": {
                    "type": "integer"
                }
            }
        },
        "main.UpdateTrainingSessionRequest_T": {
            "type": "object",
            "properties": {
                "end_time": {
                    "type": "string"
                },
                "facilitator_id": {
                    "type": "integer"
                },
                "formation_id": {
                    "type": "integer"
                },
                "location": {
                    "type": "string"
                },
                "max_capacity": {
                    "type": "integer"
                },
                "notes": {
                    "type": "string"
                },
                "region_id": {
                    "type": "integer"
                },
                "session_date": {
                    "type": "string"
                },
                "start_time": {
                    "type": "string"
                },
                "training_status_id": {
                    "type": "integer"
                },
                "workshop_id": {
                    "type": "integer"
                }
            }
        },
        "main.UpdateTrainingStatusRequest_T": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "main.UpdateTrainingTypeRequest_T": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                }
            }
        },
        "main.UpdateWorkshopRequest_T": {
            "type": "object",
            "properties": {
                "category_id": {
                    "type": "integer"
                },
                "credit_hours": {
                    "type": "integer"
                },
                "description": {
                    "description": "Fixed: was **string",
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "objectives": {
                    "description": "Fixed: was **string",
                    "type": "string"
                },
                "training_type_id": {
                    "type": "integer"
                },
                "updated_at": {
                    "type": "string"
                },
                "workshop_name": {
                    "type": "string"
                }
            }
        },
        "main.activateUserRequest": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "main.envelope": {
            "type": "object",
            "additionalProperties": {}
        },
        "main.errorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "main.registerUserRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "facilitator": {
                    "type": "boolean"
                },
                "first_name": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "localhost:4000",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Police Training API",
        Description:      "This is the API server for the Police Training application.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Filename: cmd/api/errors.go

package main

import (
        "fmt"
        "net/http"
)

/************************************************************************************************************/
// General helper functions for error handling
/************************************************************************************************************/

// logs the error message along with the request method and URL
func (app *appDependencies) logError(r *http.Request, err error) <span class="cov0" title="0">{
        method := r.Method                                          // get the HTTP method
        uri := r.URL.RequestURI()                                   // get the request URI
        app.logger.Error(err.Error(), "method", method, "uri", uri) // log the error with method and URI
}</span>

// Sends an error response in JSON format
func (app *appDependencies) errorResponseJSON(w http.ResponseWriter, r *http.Request, status int, message any) <span class="cov8" title="1">{
        errorData := envelope{"error": message}         // wrap the message in an envelope
        err := app.writeJSON(w, status, errorData, nil) // write the JSON response
        if err != nil </span><span class="cov0" title="0">{
                app.logError(r, err) // log the error
                w.WriteHeader(500)   // send a 500 Internal Server Error status code
        }</span>
}

/************************************************************************************************************/
// Individual error response functions
/************************************************************************************************************/
// error response for total server failure with a 500 status code
func (app *appDependencies) serverErrorResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        app.logError(r, err)                                                             // log the error
        message := "the server encountered a problem and could not process your request" // client message
        app.errorResponseJSON(w, r, http.StatusInternalServerError, message)             // send the error response
}</span>

// send an error response if our client messes up with a 404
func (app *appDependencies) notFoundResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        message := "the requested resource could not be found"
        app.errorResponseJSON(w, r, http.StatusNotFound, message)
}</span>

// send an error response if our client messes up with a 405
func (app *appDependencies) methodNotAllowedResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := fmt.Sprintf("the %s method is not supported for this resource", r.Method)
        app.errorResponseJSON(w, r, http.StatusMethodNotAllowed, message)
}</span>

// send an error response if our client messes up with a 400 (bad request)
func (a *appDependencies) badRequestResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        a.errorResponseJSON(w, r, http.StatusBadRequest, err.Error())
}</span>

// error response for failed validation checks with a 422 status code
func (a *appDependencies) failedValidationResponse(w http.ResponseWriter, r *http.Request, errors map[string]string) <span class="cov8" title="1">{
        a.errorResponseJSON(w, r, http.StatusUnprocessableEntity, errors)
}</span>

// For rate limit exceeded errors with a 429 status code
func (a *appDependencies) rateLimitExceededResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "rate limit exceeded"
        a.errorResponseJSON(w, r, http.StatusTooManyRequests, message)
}</span>

// for edit conflict status 409
func (a *appDependencies) editConflictResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        message := "unable to update the record due to an edit conflict, please try again"
        a.errorResponseJSON(w, r, http.StatusConflict, message)
}</span>

// Return a 401 status code
func (a *appDependencies) invalidCredentialsResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        message := "invalid authentication credentials"
        a.errorResponseJSON(w, r, http.StatusUnauthorized, message)
}</span>

// Return an authentication required status code 401
func (a *appDependencies) invalidAuthenticationTokenResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("WWW-Authenticate", "Bearer")
        message := "invalid or missing authentication token"
        a.errorResponseJSON(w, r, http.StatusUnauthorized, message)
}</span>

// Return an authentication required status code 401
func (a *appDependencies) authenticationRequiredResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "you must be authenticated to access this resource"
        a.errorResponseJSON(w, r, http.StatusUnauthorized, message)
}</span>

// Return a 403 status code
func (a *appDependencies) inactiveAccountResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "your user account must be activated to access this resource"
        a.errorResponseJSON(w, r, http.StatusForbidden, message)
}</span>

// Return a 403 status code
func (a *appDependencies) notPermittedResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "you do not have the necessary permissions to access this resource"
        a.errorResponseJSON(w, r, http.StatusForbidden, message)
}</span>

// Return a 409 status code
func (a *appDependencies) conflictResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        message := "the request could not be completed due to a conflict with the current state of the resource"
        a.errorResponseJSON(w, r, http.StatusConflict, message)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "database/sql"
        "net/http"
        "time"
)

// healthCheckHandler returns application and database status metadata.
func (app *appDependencies) healthCheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        status := "available"

        var dbStatus string
        if err := pingDatabase(app.models.User.DB); err != nil </span><span class="cov0" title="0">{
                dbStatus = "unreachable"
                status = "degraded"
        }</span> else<span class="cov0" title="0"> {
                dbStatus = "ready"
        }</span>

        <span class="cov0" title="0">payload := envelope{
                "status": status,
                "app": envelope{
                        "version":     app.version(),
                        "environment": app.config.env,
                        "time":        time.Now().UTC(),
                },
                "database": dbStatus,
        }

        if err := app.writeJSON(w, http.StatusOK, payload, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func pingDatabase(db *sql.DB) error <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Second)
        defer cancel()

        return db.PingContext(ctx)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Filename: cmd/api/helpers.go
package main

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
        "github.com/julienschmidt/httprouter"
)

/************************************************************************************************************/
// General helper functions for writing and reading JSON
/************************************************************************************************************/

// envelope is a generic map for wrapping data in JSON responses
type envelope map[string]any

// errorResponse represents the structure of error responses
type errorResponse struct {
        Error string `json:"error"`
}

// writeJSON encodes data to a JSON body and writes it to the response writer
func (app *appDependencies) writeJSON(w http.ResponseWriter, status int, data envelope, headers http.Header) error <span class="cov8" title="1">{
        // convert the data to JSON
        js, err := json.MarshalIndent(data, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">js = append(js, '\n') // add a newline for readability

        // add any headers provided in the headers parameter
        for key, value := range headers </span><span class="cov8" title="1">{
                w.Header()[key] = value
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json") // set the content type header
        w.WriteHeader(status)                              // write the status code
        _, err = w.Write(js)                               // write the JSON response body
        if err != nil </span><span class="cov0" title="0">{
                return err // return any error encountered while writing the response
        }</span>

        <span class="cov8" title="1">return nil</span> // we're done, return nil error
}

// readJSON decodes a JSON request body into the provided destination struct
func (app *appDependencies) readJSON(w http.ResponseWriter, r *http.Request, dst any) error <span class="cov8" title="1">{
        maxBytes := 1_048_576                                    // limit request body to 1MB
        r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes)) // enforce the limit

        dec := json.NewDecoder(r.Body) // create a new JSON decoder
        dec.DisallowUnknownFields()    // disallow unknown fields in the JSON

        err := dec.Decode(dst) // decode the JSON into the destination struct
        if err != nil </span><span class="cov0" title="0">{
                var (
                        syntaxError        *json.SyntaxError           // JSON syntax error
                        unmarshalTypeError *json.UnmarshalTypeError    // JSON type error
                        invalidUnmarshal   *json.InvalidUnmarshalError // invalid unmarshal error
                        maxBytesError      *http.MaxBytesError         // request body too large error
                )

                switch </span>{
                case errors.As(err, &amp;syntaxError):<span class="cov0" title="0"> // catch syntax errors
                        return fmt.Errorf("body contains badly-formed JSON (at character %d)", syntaxError.Offset)</span>
                case errors.Is(err, io.ErrUnexpectedEOF):<span class="cov0" title="0"> // catch unexpected EOF errors
                        return fmt.Errorf("body contains badly-formed JSON")</span>
                case errors.As(err, &amp;unmarshalTypeError):<span class="cov0" title="0"> // catch type errors
                        if unmarshalTypeError.Field != "" </span><span class="cov0" title="0">{ // if the error is related to a specific field
                                return fmt.Errorf("body contains badly-formed JSON (field %q)", unmarshalTypeError.Field)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("body contains badly-formed JSON (at character %d)", unmarshalTypeError.Offset)</span>
                case errors.Is(err, io.EOF):<span class="cov0" title="0"> // catch empty body error
                        return fmt.Errorf("body must not be empty")</span>
                case strings.HasPrefix(err.Error(), "json: unknown field "):<span class="cov0" title="0"> // catch unknown field errors
                        fieldName := strings.TrimPrefix(err.Error(), "json: unknown field ")
                        return fmt.Errorf("body contains unknown key %s", fieldName)</span>
                case errors.As(err, &amp;maxBytesError):<span class="cov0" title="0"> // catch request body too large error
                        return fmt.Errorf("body exceeds maximum size of 1MB")</span>
                case errors.As(err, &amp;invalidUnmarshal):<span class="cov0" title="0">
                        panic(err)</span> // this is a programmer error, so panic
                default:<span class="cov0" title="0">
                        return err</span> // return the original error for any other cases
                }
        }

        // err = dec.Decode(&amp;struct{}{}) // check for multiple JSON objects in the body
        // if errors.Is(err, io.EOF) {
        //         return fmt.Errorf("body must only contain a single JSON value") // return error if there's more than one JSON object
        // }

        <span class="cov8" title="1">return nil</span>
}

/************************************************************************************************************/
// Helper functions for reading URL parameters
/************************************************************************************************************/

// readIDParameter extracts and validates an "id" parameter from the URL
func (app *appDependencies) readIDParameter(r *http.Request) (int64, error) <span class="cov8" title="1">{

        params := httprouter.ParamsFromContext(r.Context()) // get the URL parameters from the request context

        id, err := strconv.ParseInt(params.ByName("id"), 10, 64) // parse the "id" parameter as a base-10 int64
        if err != nil || id &lt; 1 </span><span class="cov8" title="1">{
                return 0, errors.New("invalid id parameter") // return an error if parsing fails or id is less than 1
        }</span>

        <span class="cov8" title="1">return id, nil</span> // return the valid id
}

// getSingleQueryParameter retrieves a single query parameter from the URL, returning a default value if not found
func (app *appDependencies) getSingleQueryParameter(params url.Values, key string, defaultValue string) string <span class="cov8" title="1">{
        result := params.Get(key) // get the value of the specified query parameter
        if result == "" </span><span class="cov8" title="1">{
                return defaultValue // return the default value if the parameter is not found
        }</span>
        <span class="cov8" title="1">return result</span> // return the parameter value
}

// getMultipleQueryParameter retrieves multiple values for a query parameter from the URL, returning a default slice if not found
func (app *appDependencies) getMultipleQueryParameter(params url.Values, key string, defaultValue []string) []string <span class="cov0" title="0">{
        result := params.Get(key) // get the values of the specified query parameter
        if result == "" </span><span class="cov0" title="0">{
                return defaultValue // return the default slice if the parameter is not found
        }</span>
        <span class="cov0" title="0">return strings.Split(result, ",")</span> // split the parameter value by commas and return the resulting slice
}

// getSingleIntQueryParameter retrieves and validates a single integer query parameter from the URL, returning a default value if not found or invalid
func (app *appDependencies) getSingleIntQueryParameter(params url.Values, key string, defaultValue int, v *validator.Validator) int <span class="cov8" title="1">{
        result := params.Get(key) // get the value of the specified query parameter
        if result == "" </span><span class="cov8" title="1">{
                return defaultValue // return the default value if the parameter is not found
        }</span>

        <span class="cov8" title="1">i, err := strconv.Atoi(result) // attempt to convert the parameter value to an integer
        if err != nil </span><span class="cov0" title="0">{
                v.AddError(key, "must be an integer value") // add a validation error if conversion fails
                return defaultValue                         // return the default value in case of error
        }</span>

        <span class="cov8" title="1">return i</span> // return the valid integer value
}

// getOptionalBoolQueryParameter retrieves a boolean query parameter returning a pointer if present.
func (app *appDependencies) getOptionalBoolQueryParameter(params url.Values, key string, v *validator.Validator) *bool <span class="cov8" title="1">{
        value := params.Get(key)
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">b, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                v.AddError(key, "must be true or false")
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;b</span>
}

// getOptionalInt64QueryParameter retrieves an int64 query parameter returning a pointer if present.
func (app *appDependencies) getOptionalInt64QueryParameter(params url.Values, key string, v *validator.Validator) *int64 <span class="cov8" title="1">{
        value := params.Get(key)
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">i, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v.AddError(key, "must be an integer value")
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;i</span>
}

// readFilters constructs a Filters struct using standard query parameters and validates it.
func (app *appDependencies) readFilters(query url.Values, defaultSort string, defaultPageSize int, safelist []string, v *validator.Validator) data.Filters <span class="cov8" title="1">{
        filters := data.Filters{
                Page:         app.getSingleIntQueryParameter(query, "page", 1, v),
                PageSize:     app.getSingleIntQueryParameter(query, "page_size", defaultPageSize, v),
                Sort:         app.getSingleQueryParameter(query, "sort", defaultSort),
                SortSafelist: safelist,
        }

        data.ValidateFilters(v, filters)
        return filters
}</span>

/************************************************************************************************************/
// Go routine helper functions
/************************************************************************************************************/
// background runs a function in the background as a goroutine, recovering from any panics and logging them
func (app *appDependencies) background(fn func()) <span class="cov0" title="0">{
        app.wg.Add(1) // increment the wait group counter

        go func() </span><span class="cov0" title="0">{
                defer app.wg.Done() // decrement the wait group counter when the goroutine completes

                // recover from any panics and log the error
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                app.logger.Error("panic recovered in background goroutine", slog.Any("error", err)) // log the panic error
                        }</span>
                }()

                <span class="cov0" title="0">fn()</span> // execute the provided function
        }()
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "database/sql"
        "expvar"
        "flag"
        "fmt"
        "log/slog"
        "os"
        "regexp"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/mailer"
        _ "github.com/lib/pq"
)

const AppVersion = "1.0.0"

type serverConfig struct {
        port int    // server port
        env  string // environment (development, staging, production)
        db   struct {
                dsn          string        // database source name
                maxOpenConns int           // maximum number of open connections
                maxIdleConns int           // maximum number of idle connections
                maxIdleTime  time.Duration // maximum idle time for connections
        }
        cors struct {
                trustedOrigins []string // list of trusted CORS origins
        }
        limiter struct {
                rps     float64 // requests per second
                burst   int     // burst size
                enabled bool    // whether the limiter is enabled
        }
        smtp struct {
                host     string // SMTP host
                port     int    // SMTP port
                username string // SMTP username
                password string // SMTP password
                sender   string // SMTP sender address
        }
}

type appDependencies struct {
        config serverConfig   // application configuration settings
        logger *slog.Logger   // logger for structured logging
        wg     sync.WaitGroup // wait group for managing goroutines
        models data.Models
        mailer *mailer.Mailer
}

func (app *appDependencies) version() string <span class="cov0" title="0">{
        return AppVersion // return the application version
}</span>

/************************************************************************************************************/
// Main Application Entry Point
/************************************************************************************************************/
//        @title                                                Police Training API
//        @version                                        1.0.0
//        @description                                This is the API server for the Police Training application.
//        @host                                                localhost:4000
//        @basePath                                        /
//        @securityDefinitions.apikey        ApiKeyAuth
//        @in                                                        header
//        @name                                                Authorization

func main() <span class="cov0" title="0">{
        // For application setup
        cfg := loadConfig()            // load the application configuration
        logger := setUpLogger(cfg.env) // set up the logger
        db, err := openDB(cfg)         // open the database connection
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("unable to connect to database", slog.Any("error", err)) // log any error connecting to the database
                os.Exit(1)                                                            // exit if there is a database connection error
        }</span>
        <span class="cov0" title="0">defer db.Close()                                    // ensure the database connection is closed when main() exits
        logger.Info("database connection pool established") // log successful database connection

        // For metrics
        expvar.NewString("version").Set(AppVersion) // publish the application version
        expvar.Publish("goroutines", expvar.Func(func() interface{} </span><span class="cov0" title="0">{
                return runtime.NumGoroutine() // publish the number of active goroutines
        }</span>))
        <span class="cov0" title="0">expvar.Publish("database", expvar.Func(func() interface{} </span><span class="cov0" title="0">{
                return db.Stats() // publish database connection pool statistics
        }</span>))
        <span class="cov0" title="0">expvar.Publish("timestamp", expvar.Func(func() interface{} </span><span class="cov0" title="0">{
                return time.Now().Unix() // publish the current Unix timestamp
        }</span>))

        // Initialize the application dependencies
        <span class="cov0" title="0">app := &amp;appDependencies{
                config: cfg,
                logger: logger,
                models: data.NewModels(db),
        }

        if cfg.smtp.host != "" &amp;&amp; cfg.smtp.sender != "" </span><span class="cov0" title="0">{
                app.mailer = mailer.New(cfg.smtp.host, cfg.smtp.port, cfg.smtp.username, cfg.smtp.password, cfg.smtp.sender)
        }</span>

        <span class="cov0" title="0">err = app.serve() // start the HTTP server
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error starting server", slog.Any("error", err)) // log any error starting the server
                os.Exit(1)                                                    // exit if there is a server error
        }</span>
}

/************************************************************************************************************/
// API setup functions
/************************************************************************************************************/
// loadConfig loads the application configuration settings from environment variables
func loadConfig() serverConfig <span class="cov0" title="0">{
        var cfg serverConfig // create a new serverConfig instance

        flag.IntVar(&amp;cfg.port, "port", 4000, "API server port")                                        // server port
        flag.StringVar(&amp;cfg.env, "env", "development", "Environment (development|staging|production)") // environment

        // Database settings
        flag.StringVar(&amp;cfg.db.dsn, "db-dsn", "", "PostgreSQL DSN")                                                   // database source name
        flag.IntVar(&amp;cfg.db.maxOpenConns, "db-max-open-conns", 25, "PostgreSQL max open connections")                 // max open connections
        flag.IntVar(&amp;cfg.db.maxIdleConns, "db-max-idle-conns", 25, "PostgreSQL max idle connections")                 // max idle connections
        flag.DurationVar(&amp;cfg.db.maxIdleTime, "db-max-idle-time", time.Minute, "PostgreSQL max connection idle time") // max idle time

        // CORS settings
        flag.Func("cors-trusted-origins", "Trusted CORS origins (space separated)", func(s string) error </span><span class="cov0" title="0">{
                cfg.cors.trustedOrigins = strings.Fields(s) // split the input string by spaces and assign to trustedOrigins
                return nil
        }</span>)

        // Rate limiter settings
        <span class="cov0" title="0">flag.Float64Var(&amp;cfg.limiter.rps, "limiter-rps", 2, "Rate limiter maximum requests per second") // requests per second
        flag.IntVar(&amp;cfg.limiter.burst, "limiter-burst", 4, "Rate limiter maximum burst")               // burst size
        flag.BoolVar(&amp;cfg.limiter.enabled, "limiter-enabled", true, "Enable rate limiter")              // whether the limiter is enabled

        // SMTP settings
        flag.StringVar(&amp;cfg.smtp.host, "smtp-host", "smtp.mailtrap.io", "SMTP host")                             // SMTP host
        flag.IntVar(&amp;cfg.smtp.port, "smtp-port", 2525, "SMTP port")                                              // SMTP port
        flag.StringVar(&amp;cfg.smtp.username, "smtp-username", "", "SMTP username")                                 // SMTP username
        flag.StringVar(&amp;cfg.smtp.password, "smtp-password", "", "SMTP password")                                 // SMTP password
        flag.StringVar(&amp;cfg.smtp.sender, "smtp-sender", "Training &lt;noreply@example.com&gt;", "SMTP sender address") // SMTP sender address

        flag.Parse() // parse the command-line flags

        // Print out all the flag values for debugging
        if cfg.env == "development" </span><span class="cov0" title="0">{
                flag.VisitAll(func(f *flag.Flag) </span><span class="cov0" title="0">{
                        fmt.Printf("Flag %s: %v\n", f.Name, f.Value)
                }</span>)
        }

        // Regex cfg.smtp.sender and convert the first # to &lt; and last # to &gt;
        <span class="cov0" title="0">re := regexp.MustCompile(`#(.*?)#`)
        cfg.smtp.sender = re.ReplaceAllString(cfg.smtp.sender, "&lt;$1&gt;")

        if cfg.db.dsn == "" </span><span class="cov0" title="0">{
                cfg.db.dsn = os.Getenv("DB_DSN")
        }</span>
        <span class="cov0" title="0">if cfg.db.dsn == "" </span><span class="cov0" title="0">{
                panic("db-dsn must be provided via flag or DB_DSN environment variable")</span>
        }

        <span class="cov0" title="0">if len(cfg.cors.trustedOrigins) == 0 </span><span class="cov0" title="0">{
                if origins := strings.Fields(os.Getenv("CORS_TRUSTED_ORIGINS")); len(origins) &gt; 0 </span><span class="cov0" title="0">{
                        cfg.cors.trustedOrigins = origins
                }</span>
        }

        <span class="cov0" title="0">if cfg.smtp.host == "" </span><span class="cov0" title="0">{
                cfg.smtp.host = os.Getenv("SMTP_HOST")
        }</span>
        <span class="cov0" title="0">if cfg.smtp.username == "" </span><span class="cov0" title="0">{
                cfg.smtp.username = os.Getenv("SMTP_USERNAME")
        }</span>
        <span class="cov0" title="0">if cfg.smtp.password == "" </span><span class="cov0" title="0">{
                cfg.smtp.password = os.Getenv("SMTP_PASSWORD")
        }</span>
        <span class="cov0" title="0">if cfg.smtp.sender == "Training &lt;noreply@example.com&gt;" </span><span class="cov0" title="0">{
                if sender := os.Getenv("SMTP_SENDER"); sender != "" </span><span class="cov0" title="0">{
                        cfg.smtp.sender = sender
                }</span>
        }

        <span class="cov0" title="0">return cfg</span> // return the populated configuration
}

// setUpLogger initializes and returns a structured logger
func setUpLogger(env string) *slog.Logger <span class="cov0" title="0">{
        var logger *slog.Logger                                     // declare a logger variable
        logger = slog.New(slog.NewTextHandler(os.Stdout, nil))      // default to text handler
        logger = logger.With("app_version", AppVersion, "env", env) // add default fields to the logger
        return logger                                               // return the configured logger
}</span>

// openDB opens a database connection pool
func openDB(cfg serverConfig) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", cfg.db.dsn) // open a new database connection
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // return any error encountered while opening the connection
        }</span>

        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.db.maxOpenConns)   // set the maximum number of open connections
        db.SetMaxIdleConns(cfg.db.maxIdleConns)   // set the maximum number of idle connections
        db.SetConnMaxIdleTime(cfg.db.maxIdleTime) // set the maximum idle time for connections

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // create a context with a 5-second timeout
        defer cancel()                                                          // ensure the context is cancelled to free resources

        err = db.PingContext(ctx) // ping the database to verify the connection
        if err != nil </span><span class="cov0" title="0">{
                db.Close()      // close the database connection if ping fails
                return nil, err // return any error encountered while pinging the database
        }</span>

        <span class="cov0" title="0">return db, nil</span> // return the database connection pool
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// FileName: internal/data/middleware.go
package main

import (
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
        "golang.org/x/time/rate"
)

/***********************************************************************************************
 * handling Panics
 ************************************************************************************************/

// recoverPanic is a middleware that recovers from panics and returns a 500 Internal Server Error response.
func (app *appDependencies) recoverPanic(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Return a handler function that wraps the next handler
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{ // Recover from panic
                                w.Header().Set("Connection", "close")                // Close the connection after the response is sent
                                app.serverErrorResponse(w, r, fmt.Errorf("%s", err)) // Send a 500 Internal Server Error response
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
}

/***********************************************************************************************
 * rate limiting
 ************************************************************************************************/

// rateLimit is a middleware that limits the rate of incoming requests.
func (app *appDependencies) rateLimit(next http.Handler) http.Handler <span class="cov0" title="0">{
        // client is a struct to hold information about each client
        type client struct {
                limiter  *rate.Limiter // Rate limiter for the client
                lastSeen time.Time     // Last time the client was seen
        }

        var (
                mu      sync.Mutex                 // Mutex to protect access to the clients map
                clients = make(map[string]*client) // Map to hold clients by their IP address
        )

        // Start a background goroutine to clean up old clients every minute
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(time.Minute) // Sleep for one minute
                        mu.Lock()               // Lock the mutex to safely access the clients map
                        for ip, client := range clients </span><span class="cov0" title="0">{
                                if time.Since(client.lastSeen) &gt; 3*time.Minute </span><span class="cov0" title="0">{ // If the client hasn't been seen for over 3 minutes
                                        delete(clients, ip) // Remove the client from the map
                                }</span>
                        }
                        <span class="cov0" title="0">mu.Unlock()</span> // Unlock the mutex
                }
        }()

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if app.config.limiter.enabled </span><span class="cov0" title="0">{ // Check if rate limiting is enabled
                        ip := r.RemoteAddr // Get the client's IP address

                        mu.Lock()                            // Lock the mutex to safely access the clients map
                        if _, found := clients[ip]; !found </span><span class="cov0" title="0">{ // If the client is not already in the map
                                clients[ip] = &amp;client{
                                        limiter: rate.NewLimiter(rate.Limit(app.config.limiter.rps), app.config.limiter.burst), // Create a new rate limiter for the client
                                }
                        }</span>
                        <span class="cov0" title="0">clients[ip].lastSeen = time.Now() // Update the last seen time for the client
                        if !clients[ip].limiter.Allow() </span><span class="cov0" title="0">{ // Check if the client is allowed to make a request
                                mu.Unlock()                         // Unlock the mutex before returning
                                app.rateLimitExceededResponse(w, r) // Send a 429 Too Many Requests response
                                return
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span> // Unlock the mutex
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
}

/***********************************************************************************************
 * Enabling CORS
 ************************************************************************************************/
// enableCORS is a middleware that adds CORS headers to the response.
func (app *appDependencies) enableCORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Vary", "Origin")                        // Indicate that the response varies based on the Origin header
                w.Header().Set("Vary", "Access-Control-Request-Method") // Indicate that the response varies based on the Access-Control-Request-Method header

                origin := r.Header.Get("Origin") // Get the Origin header from the request

                if origin != "" </span><span class="cov0" title="0">{
                        for i := range app.config.cors.trustedOrigins </span><span class="cov0" title="0">{
                                // Check if the origin is in the trusted origins list
                                if origin == app.config.cors.trustedOrigins[i] </span><span class="cov0" title="0">{
                                        w.Header().Set("Access-Control-Allow-Origin", origin) // Allow the specific origin
                                        if r.Method == http.MethodOptions &amp;&amp; r.Header.Get("Access-Control-Request-Method") != "" </span><span class="cov0" title="0">{
                                                // Handle preflight request
                                                w.Header().Set("Access-Control-Allow-Methods", "OPTIONS, PUT, PATCH, DELETE") // Allowed methods
                                                w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type") // Allowed headers
                                                w.WriteHeader(http.StatusOK)                                                  // Respond with 200 OK
                                                return
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
}

/***********************************************************************************************
 * Authentication and Authorization
 ************************************************************************************************/

// authenticate is a middleware that checks for a valid authentication token in the request.
func (app *appDependencies) authenticate(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Add("Vary", "Authorization") // Indicate that the response varies based on the Authorization header

                authorizationHeader := r.Header.Get("Authorization") // Get the Authorization header

                // If the Authorization header is empty, set the user in the context to anonymous and call the next handler
                if authorizationHeader == "" </span><span class="cov0" title="0">{
                        r = app.contextSetUser(r, data.AnonymousUser) // Set the user in the context to anonymous
                        next.ServeHTTP(w, r)                          // Call the next handler in the chain
                        return                                        // Return to avoid further processing
                }</span>

                // Split the Authorization header into parts
                <span class="cov0" title="0">headerParts := strings.Split(authorizationHeader, " ")   // Split the header by spaces
                if len(headerParts) != 2 || headerParts[0] != "Bearer" </span><span class="cov0" title="0">{ // Check if the header is in the correct format
                        app.invalidAuthenticationTokenResponse(w, r) // Send a 401 Unauthorized response
                        return                                       // Return to avoid further processing
                }</span>

                <span class="cov0" title="0">tokenPlaintext := headerParts[1] // Get the token part of the header

                // Validate the token plaintext
                v := validator.New()                                              // Create a new validator instance
                if data.ValidateTokenPlaintext(v, tokenPlaintext); !v.IsEmpty() </span><span class="cov0" title="0">{ // Validate the token format
                        app.invalidAuthenticationTokenResponse(w, r) // Send a 401 Unauthorized response
                        return                                       // Return to avoid further processing
                }</span>

                // Get the user associated with the token
                <span class="cov0" title="0">user, err := app.models.User.GetForToken(data.ScopeAuthentication, tokenPlaintext) // Get the user for the token
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                                app.invalidAuthenticationTokenResponse(w, r)</span> // Send a 401 Unauthorized response if the token is not found
                        default:<span class="cov0" title="0">
                                app.serverErrorResponse(w, r, err)</span> // Send a 500 Internal Server Error response for other errors
                        }
                        <span class="cov0" title="0">return</span> // Return to avoid further processing
                }

                // Set the user in the request context
                <span class="cov0" title="0">r = app.contextSetUser(r, user) // Set the authenticated user in the context

                next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
}

// requireAuthenticatedUser is a middleware that ensures the user is authenticated.
func (app *appDependencies) requireAuthenticatedUser(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                user := app.contextGetUser(r) // Get the user from the context

                if user.IsAnonymous() </span><span class="cov0" title="0">{ // Check if the user is anonymous
                        app.authenticationRequiredResponse(w, r) // Send a 401 Unauthorized response
                        return                                   // Return to avoid further processing
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
}

// requireActivatedUser is a middleware that ensures the user is activated.
func (app *appDependencies) requireActivatedUser(next http.Handler) http.Handler <span class="cov0" title="0">{
        fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                user := app.contextGetUser(r) // Get the user from the context

                if !user.IsActivated </span><span class="cov0" title="0">{ // Check if the user is not activated
                        app.inactiveAccountResponse(w, r) // Send a 403 Forbidden response
                        return                            // Return to avoid further processing
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
        })
        <span class="cov0" title="0">return app.requireAuthenticatedUser(fn)</span>
}

/************************************************************************************************************/
// Permissions
/************************************************************************************************************/
// requireRole is a middleware that ensures the user has a specific role.
func (app *appDependencies) requirePermissions(requiredPermissions string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        user := app.contextGetUser(r) // Get the user from the context

                        // Check if the user has the required permission
                        hasPermissions, err := app.models.Role.HasPermission(user.ID, requiredPermissions)
                        if err != nil </span><span class="cov0" title="0">{
                                app.serverErrorResponse(w, r, err) // Send a 500 Internal Server Error response for errors
                                return
                        }</span>

                        <span class="cov0" title="0">if !hasPermissions </span><span class="cov0" title="0">{
                                app.notPermittedResponse(w, r) // Send a 403 Forbidden response if not permitted
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span> // Call the next handler in the chain
                })
                <span class="cov0" title="0">return app.requireActivatedUser(fn)</span> // Ensure the user is activated before checking permissions
        }
}

/************************************************************************************************************/
//  Metrics
/************************************************************************************************************/

// metricsResponseWriter is a custom http.ResponseWriter that captures the status code of the response.
type metricsResponseWriter struct {
        wrapped       http.ResponseWriter // The original ResponseWriter
        statusCode    int                 // The status code of the response
        headerWritten bool                // Flag to indicate if the header has been written
}

// newMetricsResponseWriter creates a new metricsResponseWriter that wraps the given http.ResponseWriter.
func newMetricsResponseWriter(w http.ResponseWriter) *metricsResponseWriter <span class="cov0" title="0">{
        return &amp;metricsResponseWriter{wrapped: w, statusCode: http.StatusOK} // Default status code to 200 OK
}</span>

// Header returns the header map that will be sent by WriteHeader.
func (mw *metricsResponseWriter) Header() http.Header <span class="cov0" title="0">{
        return mw.wrapped.Header() // Delegate to the wrapped ResponseWriter
}</span>

// WriterHeader sends an HTTP response header with the provided status code.
func (mw *metricsResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        mw.wrapped.WriteHeader(code) // Delegate to the wrapped ResponseWriter
        if !mw.headerWritten </span><span class="cov0" title="0">{
                mw.statusCode = code    // Capture the status code
                mw.headerWritten = true // Mark that the header has been written
        }</span>
}

// Write writes the data to the connection as part of an HTTP reply.
func (mw *metricsResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        mw.headerWritten = true    // Mark that the header has been written
        return mw.wrapped.Write(b) // Delegate to the wrapped ResponseWriter
}</span>

// Unwrap returns the original http.ResponseWriter.
func (mw *metricsResponseWriter) Unwrap() http.ResponseWriter <span class="cov0" title="0">{
        return mw.wrapped // Return the wrapped ResponseWriter
}</span>

// metrics is a middleware that collects and exposes various metrics about the HTTP requests.
func (app *appDependencies) metrics(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Define variables to hold the metrics
        var (
                totalResponsesSentByStatus      = expvar.NewMap("total_responses_sent_by_status")     // Map to hold the count of responses by status code
                totalRequestsReceived           = expvar.NewInt("total_requests_received")            // Counter for total requests received
                totalResponsesSent              = expvar.NewInt("total_responses_sent")               // Counter for total responses sent
                totalProcessingTimeMicroseconds = expvar.NewInt("total_processing_time_microseconds") // Counter for total processing time in microseconds
        )

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()                                            // Record the start time of the request
                totalRequestsReceived.Add(1)                                   // Increment the total requests received counter
                mw := newMetricsResponseWriter(w)                              // Create a new metrics response writer
                next.ServeHTTP(mw, r)                                          // Call the next handler in the chain
                totalResponsesSent.Add(1)                                      // Increment the total responses sent counter
                totalResponsesSentByStatus.Add(strconv.Itoa(mw.statusCode), 1) // Increment the count for the specific status code
                duration := time.Since(start).Microseconds()                   // Calculate the processing time in microseconds
                totalProcessingTimeMicroseconds.Add(duration)                  // Add the processing time to the total
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Filename: cmd/api/officers.go
package main

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

// createOfficerHandler creates a new officer record
//
//        @Summary                Create a new officer
//        @Description        Create a new officer record linked to a user
//        @Tags                        officers
//        @Accept                        json
//        @Produce                json
//        @Param                        officer        body                CreateOfficerRequest_T        true        "Officer data"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/officers [post]
func (app *appDependencies) createOfficerHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                UserID           int64  `json:"user_id"`
                RegulationNumber string `json:"regulation_number"`
                RankID           int64  `json:"rank_id"`
                PostingID        int64  `json:"posting_id"`
                FormationID      int64  `json:"formation_id"`
                RegionID         int64  `json:"region_id"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">officer := &amp;data.Officer{
                UserID:           input.UserID,
                RegulationNumber: input.RegulationNumber,
                RankID:           input.RankID,
                PostingID:        input.PostingID,
                FormationID:      input.FormationID,
                RegionID:         input.RegionID,
        }

        v := validator.New()
        data.ValidateOfficer(v, officer)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.Officer.Insert(officer); err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("regulation_number", "an officer with this regulation number already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov8" title="1">
                        v.AddError("references", "one or more referenced records do not exist")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/officers/%d", officer.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"officer": officer}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showOfficerHandler retrieves an officer by ID
//
//        @Summary                Get an officer
//        @Description        Retrieve an officer by their ID
//        @Tags                        officers
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Officer ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/officers/{id} [get]
func (app *appDependencies) showOfficerHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">officer, err := app.models.Officer.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"officer": officer}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showOfficerWithDetailsHandler retrieves an officer with all related information
//
//        @Summary                Get an officer with details
//        @Description        Retrieve an officer with all related information (user, rank, posting, etc.)
//        @Tags                        officers
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Officer ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/officers/{id}/details [get]
func (app *appDependencies) showOfficerWithDetailsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">officer, err := app.models.Officer.GetWithDetails(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"officer": officer}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listOfficersHandler returns a filtered list of officers
//
//        @Summary                List officers
//        @Description        Retrieve a list of officers with optional filtering and pagination
//        @Tags                        officers
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        regulation_number        query                string        false        "Filter by regulation number"
//        @Param                        rank_id                                query                int                false        "Filter by rank ID"
//        @Param                        posting_id                        query                int                false        "Filter by posting ID"
//        @Param                        formation_id                query                int                false        "Filter by formation ID"
//        @Param                        region_id                        query                int                false        "Filter by region ID"
//        @Success                200                                        {object}        envelope
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/officers [get]
func (app *appDependencies) listOfficersHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        v := validator.New()

        filters := data.Filters{
                Page:     app.getSingleIntQueryParameter(query, "page", 1, v),
                PageSize: app.getSingleIntQueryParameter(query, "page_size", 20, v),
                Sort:     app.getSingleQueryParameter(query, "sort", "id"),
                SortSafelist: []string{
                        "id", "regulation_number", "created_at",
                        "-id", "-regulation_number", "-created_at",
                },
        }

        data.ValidateFilters(v, filters)

        regulationNumber := app.getSingleQueryParameter(query, "regulation_number", "")
        rankID := app.getOptionalInt64QueryParameter(query, "rank_id", v)
        postingID := app.getOptionalInt64QueryParameter(query, "posting_id", v)
        formationID := app.getOptionalInt64QueryParameter(query, "formation_id", v)
        regionID := app.getOptionalInt64QueryParameter(query, "region_id", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">officers, metadata, err := app.models.Officer.GetAll(regulationNumber, rankID, postingID, formationID, regionID, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">payload := envelope{
                "officers": officers,
                "metadata": metadata,
        }

        if err := app.writeJSON(w, http.StatusOK, payload, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateOfficerHandler updates an existing officer
//
//        @Summary                Update an officer
//        @Description        Update an existing officer's information
//        @Tags                        officers
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                path                int                                        true        "Officer ID"
//        @Param                        officer        body                UpdateOfficerRequest_T        true        "Officer update data"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                404                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/officers/{id} [patch]
func (app *appDependencies) updateOfficerHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">officer, err := app.models.Officer.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                RegulationNumber *string `json:"regulation_number"`
                RankID           *int64  `json:"rank_id"`
                PostingID        *int64  `json:"posting_id"`
                FormationID      *int64  `json:"formation_id"`
                RegionID         *int64  `json:"region_id"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if input.RegulationNumber != nil </span><span class="cov8" title="1">{
                officer.RegulationNumber = *input.RegulationNumber
        }</span>
        <span class="cov8" title="1">if input.RankID != nil </span><span class="cov8" title="1">{
                officer.RankID = *input.RankID
        }</span>
        <span class="cov8" title="1">if input.PostingID != nil </span><span class="cov8" title="1">{
                officer.PostingID = *input.PostingID
        }</span>
        <span class="cov8" title="1">if input.FormationID != nil </span><span class="cov0" title="0">{
                officer.FormationID = *input.FormationID
        }</span>
        <span class="cov8" title="1">if input.RegionID != nil </span><span class="cov0" title="0">{
                officer.RegionID = *input.RegionID
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateOfficer(v, officer)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.Officer.Update(officer); err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("regulation_number", "an officer with this regulation number already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov8" title="1">
                        v.AddError("references", "one or more referenced records do not exist")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"officer": officer}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// deleteOfficerHandler removes an officer
//
//        @Summary                Delete an officer
//        @Description        Remove an officer record
//        @Tags                        officers
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Officer ID"
//        @Success                200        {object}        envelope{message=string}
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/officers/{id} [delete]
func (app *appDependencies) deleteOfficerHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.Officer.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"message": "officer successfully deleted"}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// getUserOfficerHandler retrieves an officer by user ID
//
//        @Summary                Get officer by user ID
//        @Description        Retrieve an officer record by their associated user ID
//        @Tags                        officers
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "User ID"
//        @Success                200                {object}        envelope
//        @Failure                404                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/users/{user_id}/officer [get]
func (app *appDependencies) getUserOfficerHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">officer, err := app.models.Officer.GetByUserID(userID)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"officer": officer}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

func likeSearch(value string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%%%s%%", value)</span>
}

/*********************** Regions ***********************/
// createRegionHandler handles the creation of a new region.
//        @Summary                Create a new region
//        @Description        Create a new region
//        @Tags                        regions
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        region        body                CreateRegionRequest_T        true        "Region data"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/regions [post]
func (app *appDependencies) createRegionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateRegionRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">region := &amp;data.Region{Region: CreateRegionRequest.Region}

        v := validator.New()
        data.ValidateRegion(v, region)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Region.Insert(region); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("region", "a region with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/regions/%d", region.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"region": region}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showRegionHandler retrieves and returns a region by its ID.
//
//        @Summary                Get a region
//        @Description        Retrieve a region by its ID
//        @Tags                        regions
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Region ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/regions/{id} [get]
func (app *appDependencies) showRegionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">region, err := app.models.Region.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"region": region}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listRegionsHandler returns a filtered list of regions.
//
//        @Summary                List regions
//        @Description        Retrieve a list of regions with optional filtering
//        @Tags                        regions
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        region                query                string        false        "Filter by region name"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/regions [get]
func (app *appDependencies) listRegionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "region", 20, []string{"region", "-region", "id", "-id"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">search := likeSearch(app.getSingleQueryParameter(query, "region", ""))

        regions, metadata, err := app.models.Region.GetAll(search, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"regions": regions, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateRegionHandler performs a partial update on a region record.
//
//        @Summary                Update a region
//        @Description        Perform a partial update on a region record
//        @Tags                        regions
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                path                int                                                true        "Region ID"
//        @Param                        region        body                UpdateRegionRequest_T        true        "Region data"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                404                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/regions/{id} [patch]
func (app *appDependencies) updateRegionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">region, err := app.models.Region.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateRegionRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateRegionRequest.Region != nil </span><span class="cov0" title="0">{
                region.Region = *UpdateRegionRequest.Region
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateRegion(v, region)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Region.Update(region); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("region", "a region with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"region": region}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Formations ***********************/
// createFormationHandler handles the creation of a new formation.
//        @Summary                Create a new formation
//        @Description        Create a new formation
//        @Tags                        formations
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        formation        body                CreateFormationRequest_T        true        "Formation data"
//        @Success                201                        {object}        envelope
//        @Failure                400                        {object}        errorResponse
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/formations [post]
func (app *appDependencies) createFormationHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;UpdateFormationRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">formation := &amp;data.Formation{
                Formation: *UpdateFormationRequest.Formation,
                RegionID:  *UpdateFormationRequest.RegionID,
        }

        v := validator.New()
        data.ValidateFormation(v, formation)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Formation.Insert(formation); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("formation", "a formation with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov0" title="0">
                        v.AddError("region_id", "must reference an existing region")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/formations/%d", formation.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"formation": formation}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showFormationHandler retrieves a formation by id.
//
//        @Summary                Get a formation
//        @Description        Retrieve a formation by its ID
//        @Tags                        formations
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Formation ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/formations/{id} [get]
func (app *appDependencies) showFormationHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">formation, err := app.models.Formation.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"formation": formation}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listFormationsHandler returns formations filtered by name and region.
//
//        @Summary                List formations
//        @Description        Retrieve a list of formations with optional filtering by name and region
//        @Tags                        formations
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        formation        query                string        false        "Filter by formation name"
//        @Param                        region_id        query                int                false        "Filter by region ID"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/formations [get]
func (app *appDependencies) listFormationsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "formation", 20, []string{"formation", "-formation", "id", "-id", "region_id", "-region_id", "created_at", "-created_at"}, v)

        regionID := app.getOptionalInt64QueryParameter(query, "region_id", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "formation", ""))

        formations, metadata, err := app.models.Formation.GetAll(name, regionID, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"formations": formations, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateFormationHandler performs a partial update on a formation record.
//
//        @Summary                Update a formation
//        @Description        Perform a partial update on a formation record
//        @Tags                        formations
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                        path                int                                                        true        "Formation ID"
//        @Param                        formation        body                UpdateFormationRequest_T        true        "Formation data"
//        @Success                200                        {object}        envelope
//        @Failure                400                        {object}        errorResponse
//        @Failure                404                        {object}        errorResponse
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/formations/{id} [patch]
func (app *appDependencies) updateFormationHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">formation, err := app.models.Formation.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateFormationRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateFormationRequest.Formation != nil </span><span class="cov0" title="0">{
                formation.Formation = *UpdateFormationRequest.Formation
        }</span>
        <span class="cov0" title="0">if UpdateFormationRequest.RegionID != nil </span><span class="cov0" title="0">{
                formation.RegionID = *UpdateFormationRequest.RegionID
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateFormation(v, formation)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Formation.Update(formation); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("formation", "a formation with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov0" title="0">
                        v.AddError("region_id", "must reference an existing region")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"formation": formation}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Postings ***********************/

// createPostingHandler handles the creation of a new posting.
//
//        @Summary                Create a new posting
//        @Description        Create a new posting
//        @Tags                        postings
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        posting        body                CreatePostingRequest_T        true        "Posting data"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/postings [post]
func (app *appDependencies) createPostingHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreatePostingRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">posting := &amp;data.Posting{
                Posting: CreatePostingRequest.Posting,
                Code:    CreatePostingRequest.Code,
        }

        v := validator.New()
        data.ValidatePosting(v, posting)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Posting.Insert(posting); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("posting", "a posting with these details already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/postings/%d", posting.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"posting": posting}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showPostingHandler retrieves and returns a posting by its ID.
//
//        @Summary                Get a posting
//        @Description        Retrieve a posting by its ID
//        @Tags                        postings
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Posting ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/postings/{id} [get]
func (app *appDependencies) showPostingHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">posting, err := app.models.Posting.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"posting": posting}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listPostingsHandler returns a filtered list of postings.
//
//        @Summary                List postings
//        @Description        Retrieve a list of postings with optional filtering by name and code
//        @Tags                        postings
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        posting                query                string        false        "Filter by posting name"
//        @Param                        code                query                string        false        "Filter by posting code"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/postings [get]
func (app *appDependencies) listPostingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "posting", 20, []string{"posting", "-posting", "id", "-id", "code", "-code", "created_at", "-created_at"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "posting", ""))
        code := likeSearch(app.getSingleQueryParameter(query, "code", ""))

        postings, metadata, err := app.models.Posting.GetAll(name, code, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"postings": postings, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updatePostingHandler performs a partial update on a posting record.
//
//        @Summary                Update a posting
//        @Description        Perform a partial update on a posting record
//        @Tags                        postings
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                path                int                                                true        "Posting ID"
//        @Param                        posting        body                UpdatePostingRequest_T        true        "Posting data"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                404                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/postings/{id} [patch]
func (app *appDependencies) updatePostingHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">posting, err := app.models.Posting.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdatePostingRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">posting.Posting = UpdatePostingRequest.Posting
        posting.Code = UpdatePostingRequest.Code
        v := validator.New()
        data.ValidatePosting(v, posting)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Posting.Update(posting); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("posting", "a posting with these details already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"posting": posting}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Ranks ***********************/

// createRankHandler handles the creation of a new rank.
//
//        @Summary                Create a new rank
//        @Description        Create a new rank
//        @Tags                        ranks
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        rank        body                CreateRankRequest_T        true        "Rank data"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/ranks [post]
func (app *appDependencies) createRankHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateRankRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">rank := &amp;data.Rank{
                Rank:                CreateRankRequest.Rank,
                Code:                CreateRankRequest.Code,
                AnnualTrainingHours: CreateRankRequest.AnnualTrainingHoursRequired,
        }

        v := validator.New()
        data.ValidateRank(v, rank)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Rank.Insert(rank); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("rank", "a rank with these details already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/ranks/%d", rank.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"rank": rank}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showRankHandler retrieves and returns a rank by its ID.
//
//        @Summary                Get a rank
//        @Description        Retrieve a rank by its ID
//        @Tags                        ranks
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Rank ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/ranks/{id} [get]
func (app *appDependencies) showRankHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">rank, err := app.models.Rank.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"rank": rank}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listRanksHandler returns a filtered list of ranks.
//
//        @Summary                List ranks
//        @Description        Retrieve a list of ranks with optional filtering by rank name and code
//        @Tags                        ranks
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        rank                query                string        false        "Filter by rank name"
//        @Param                        code                query                string        false        "Filter by rank code"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/ranks [get]
func (app *appDependencies) listRanksHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "rank", 20, []string{"rank", "-rank", "code", "-code", "annual_training_hours_required", "-annual_training_hours_required", "id", "-id"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">rankFilter := likeSearch(app.getSingleQueryParameter(query, "rank", ""))
        codeFilter := likeSearch(app.getSingleQueryParameter(query, "code", ""))

        ranks, metadata, err := app.models.Rank.GetAll(rankFilter, codeFilter, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"ranks": ranks, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateRankHandler performs a partial update on a rank record.
//
//        @Summary                Update a rank
//        @Description        Perform a partial update on a rank record
//        @Tags                        ranks
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                path                int                                        true        "Rank ID"
//        @Param                        rank        body                UpdateRankRequest_T        true        "Rank data"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                404                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/ranks/{id} [patch]
func (app *appDependencies) updateRankHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">rank, err := app.models.Rank.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateRankRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateRankRequest.Rank != nil </span><span class="cov0" title="0">{
                rank.Rank = *UpdateRankRequest.Rank
        }</span>
        <span class="cov0" title="0">if UpdateRankRequest.Code != nil </span><span class="cov0" title="0">{
                rank.Code = *UpdateRankRequest.Code
        }</span>
        <span class="cov0" title="0">if UpdateRankRequest.AnnualTrainingHoursRequired != nil </span><span class="cov0" title="0">{
                rank.AnnualTrainingHours = *UpdateRankRequest.AnnualTrainingHoursRequired
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateRank(v, rank)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.Rank.Update(rank); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("rank", "a rank with these details already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"rank": rank}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Training Types ***********************/

// createTrainingTypeHandler handles the creation of a new training type.
//
//        @Summary                Create a new training type
//        @Description        Create a new training type
//        @Tags                        training-types
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        training_type        body                CreateTrainingTypeRequest_T        true        "Training type data"
//        @Success                201                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/training/types [post]
func (app *appDependencies) createTrainingTypeHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateTrainingTypeRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">trainingType := &amp;data.TrainingType{Type: CreateTrainingTypeRequest.Type}

        v := validator.New()
        data.ValidateTrainingType(v, trainingType)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingType.Insert(trainingType); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("type", "a training type with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/training-types/%d", trainingType.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"training_type": trainingType}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showTrainingTypeHandler retrieves and returns a training type by its ID.
//
//        @Summary                Get a training type
//        @Description        Retrieve a training type by its ID
//        @Tags                        training-types
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Training type ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/training/types/{id} [get]
func (app *appDependencies) showTrainingTypeHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">typeRecord, err := app.models.TrainingType.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_type": typeRecord}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listTrainingTypesHandler returns a filtered list of training types.
//
//        @Summary                List training types
//        @Description        Retrieve a list of training types with optional filtering by type name
//        @Tags                        training-types
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        type                query                string        false        "Filter by training type name"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/training/types [get]
func (app *appDependencies) listTrainingTypesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "type", 20, []string{"type", "-type", "id", "-id"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "type", ""))

        types, metadata, err := app.models.TrainingType.GetAll(name, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_types": types, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateTrainingTypeHandler performs a partial update on a training type record.
//
//        @Summary                Update a training type
//        @Description        Perform a partial update on a training type record
//        @Tags                        training-types
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                path                int                                                        true        "Training type ID"
//        @Param                        training_type        body                UpdateTrainingTypeRequest_T        true        "Training type data"
//        @Success                200                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                404                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/training/types/{id} [patch]
func (app *appDependencies) updateTrainingTypeHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">typeRecord, err := app.models.TrainingType.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateTrainingTypeRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateTrainingTypeRequest.Type != nil </span><span class="cov0" title="0">{
                typeRecord.Type = *UpdateTrainingTypeRequest.Type
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateTrainingType(v, typeRecord)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingType.Update(typeRecord); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("type", "a training type with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_type": typeRecord}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Training Categories ***********************/

// createTrainingCategoryHandler handles the creation of a new training category.
//
//        @Summary                Create a new training category
//        @Description        Create a new training category
//        @Tags                        training-categories
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        training_category        body                CreateTrainingCategoryRequest_T        true        "Training category data"
//        @Success                201                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/training/categories [post]
func (app *appDependencies) createTrainingCategoryHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateTrainingCategoryRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">category := &amp;data.TrainingCategory{
                Name:     CreateTrainingCategoryRequest.Name,
                IsActive: true,
        }
        if CreateTrainingCategoryRequest.IsActive != nil </span><span class="cov0" title="0">{
                category.IsActive = *CreateTrainingCategoryRequest.IsActive
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateTrainingCategory(v, category)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingCategory.Insert(category); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("name", "a training category with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/training/categories/%d", category.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"training_category": category}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showTrainingCategoryHandler retrieves and returns a training category by its ID.
//
//        @Summary                Get a training category
//        @Description        Retrieve a training category by its ID
//        @Tags                        training-categories
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Training category ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/training/categories/{id} [get]
func (app *appDependencies) showTrainingCategoryHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">category, err := app.models.TrainingCategory.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_category": category}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listTrainingCategoriesHandler returns a filtered list of training categories.
//
//        @Summary                List training categories
//        @Description        Retrieve a list of training categories with optional filtering by name and active status
//        @Tags                        training-categories
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        name                query                string        false        "Filter by category name"
//        @Param                        is_active        query                bool        false        "Filter by active status"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/training/categories [get]
func (app *appDependencies) listTrainingCategoriesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "name", 20, []string{"name", "-name", "id", "-id", "created_at", "-created_at"}, v)

        isActive := app.getOptionalBoolQueryParameter(query, "is_active", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "name", ""))

        categories, metadata, err := app.models.TrainingCategory.GetAll(name, isActive, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_categories": categories, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateTrainingCategoryHandler performs a partial update on a training category record.
//
//        @Summary                Update a training category
//        @Description        Perform a partial update on a training category record
//        @Tags                        training-categories
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                        path                int                                                                true        "Training category ID"
//        @Param                        training_category        body                UpdateTrainingCategoryRequest_T        true        "Training category data"
//        @Success                200                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                404                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/training/categories/{id} [patch]
func (app *appDependencies) updateTrainingCategoryHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">category, err := app.models.TrainingCategory.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateTrainingCategoryRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateTrainingCategoryRequest.Name != nil </span><span class="cov0" title="0">{
                category.Name = *UpdateTrainingCategoryRequest.Name
        }</span>
        <span class="cov0" title="0">if UpdateTrainingCategoryRequest.IsActive != nil </span><span class="cov0" title="0">{
                category.IsActive = *UpdateTrainingCategoryRequest.IsActive
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateTrainingCategory(v, category)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingCategory.Update(category); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("name", "a training category with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_category": category}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Training Status ***********************/

// createTrainingStatusHandler handles the creation of a new training status.
//
//        @Summary                Create a new training status
//        @Description        Create a new training status
//        @Tags                        training-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        training_status        body                CreateTrainingStatusRequest_T        true        "Training status data"
//        @Success                201                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/training/status [post]
func (app *appDependencies) createTrainingStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateTrainingStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">status := &amp;data.TrainingStatus{Status: CreateTrainingStatusRequest.Status}

        v := validator.New()
        data.ValidateTrainingStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingStatus.Insert(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "a training status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/training/status/%d", status.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"training_status": status}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showTrainingStatusHandler retrieves and returns a training status by its ID.
//
//        @Summary                Get a training status
//        @Description        Retrieve a training status by its ID
//        @Tags                        training-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Training status ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/training/status/{id} [get]
func (app *appDependencies) showTrainingStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.TrainingStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// getTrainingStatusesHandler returns a filtered list of training statuses.
//
//        @Summary                List training statuses
//        @Description        Retrieve a list of training statuses with optional filtering by status name
//        @Tags                        training-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        status                query                string        false        "Filter by status name"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/training/status [get]
func (app *appDependencies) getTrainingStatusesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "status", 20, []string{"status", "-status", "id", "-id", "created_at", "-created_at"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "status", ""))

        statuses, metadata, err := app.models.TrainingStatus.GetAll(name, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_statuses": statuses, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateTrainingStatusHandler performs a partial update on a training status record.
//
//        @Summary                Update a training status
//        @Description        Perform a partial update on a training status record
//        @Tags                        training-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                path                int                                                                true        "Training status ID"
//        @Param                        training_status        body                UpdateTrainingStatusRequest_T        true        "Training status data"
//        @Success                200                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                404                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/training/status/{id} [patch]
func (app *appDependencies) updateTrainingStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.TrainingStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateTrainingStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateTrainingStatusRequest.Status != nil </span><span class="cov0" title="0">{
                status.Status = *UpdateTrainingStatusRequest.Status
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateTrainingStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.TrainingStatus.Update(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "a training status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"training_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Enrollment Status ***********************/

// createEnrollmentStatusHandler handles the creation of a new enrollment status.
//
//        @Summary                Create a new enrollment status
//        @Description        Create a new enrollment status
//        @Tags                        enrollment-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        enrollment_status        body                CreateEnrollmentStatusRequest_T        true        "Enrollment status data"
//        @Success                201                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/enrollment/status [post]
func (app *appDependencies) createEnrollmentStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if err := app.readJSON(w, r, &amp;CreateEnrollmentStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">status := &amp;data.EnrollmentStatus{Status: CreateEnrollmentStatusRequest.Status}

        v := validator.New()
        data.ValidateEnrollmentStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.EnrollmentStatus.Insert(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "an enrollment status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/enrollment/status/%d", status.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"enrollment_status": status}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showEnrollmentStatusHandler retrieves and returns an enrollment status by its ID.
//
//        @Summary                Get an enrollment status
//        @Description        Retrieve an enrollment status by its ID
//        @Tags                        enrollment-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Enrollment status ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/enrollment/status/{id} [get]
func (app *appDependencies) showEnrollmentStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.EnrollmentStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"enrollment_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listEnrollmentStatusesHandler returns a filtered list of enrollment statuses.
//
//        @Summary                List enrollment statuses
//        @Description        Retrieve a list of enrollment statuses with optional filtering by status name
//        @Tags                        enrollment-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        status                query                string        false        "Filter by status name"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/enrollment/status [get]
func (app *appDependencies) listEnrollmentStatusesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "status", 20, []string{"status", "-status", "id", "-id", "created_at", "-created_at"}, v)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "status", ""))

        statuses, metadata, err := app.models.EnrollmentStatus.GetAll(name, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"enrollment_statuses": statuses, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateEnrollmentStatusHandler performs a partial update on an enrollment status record.
//
//        @Summary                Update an enrollment status
//        @Description        Perform a partial update on an enrollment status record
//        @Tags                        enrollment-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                        path                int                                                                true        "Enrollment status ID"
//        @Param                        enrollment_status        body                UpdateEnrollmentStatusRequest_T        true        "Enrollment status data"
//        @Success                200                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                404                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/enrollment/status/{id} [patch]
func (app *appDependencies) updateEnrollmentStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.EnrollmentStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateEnrollmentStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateEnrollmentStatusRequest.Status != nil </span><span class="cov0" title="0">{
                status.Status = *UpdateEnrollmentStatusRequest.Status
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateEnrollmentStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.EnrollmentStatus.Update(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "an enrollment status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"enrollment_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Attendance Status ***********************/

// createAttendanceStatusHandler handles the creation of a new attendance status.
//
//        @Summary                Create a new attendance status
//        @Description        Create a new attendance status
//        @Tags                        attendance-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        attendance_status        body                CreateAttendanceStatusRequest_T        true        "Attendance status data"
//        @Success                201                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/attendance/status [post]
func (app *appDependencies) createAttendanceStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := app.readJSON(w, r, &amp;CreateAttendanceStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">status := &amp;data.AttendanceStatus{
                Status:          CreateAttendanceStatusRequest.Status,
                CountsAsPresent: CreateAttendanceStatusRequest.CountsAsPresent,
        }

        v := validator.New()
        data.ValidateAttendanceStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.AttendanceStatus.Insert(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "an attendance status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/attendance/status/%d", status.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"attendance_status": status}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showAttendanceStatusHandler retrieves and returns an attendance status by its ID.
//
//        @Summary                Get an attendance status
//        @Description        Retrieve an attendance status by its ID
//        @Tags                        attendance-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Attendance status ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/attendance/status/{id} [get]
func (app *appDependencies) showAttendanceStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.AttendanceStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"attendance_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listAttendanceStatusesHandler returns a filtered list of attendance statuses.
//
//        @Summary                List attendance statuses
//        @Description        Retrieve a list of attendance statuses with optional filtering
//        @Tags                        attendance-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        status                                query                string        false        "Filter by status name"
//        @Param                        counts_as_present        query                bool        false        "Filter by counts as present flag"
//        @Param                        page                                query                int                false        "Page number for pagination"
//        @Param                        page_size                        query                int                false        "Number of items per page"
//        @Param                        sort                                query                string        false        "Sort order"
//        @Success                200                                        {object}        envelope
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/attendance/status [get]
func (app *appDependencies) listAttendanceStatusesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "status", 20, []string{"status", "-status", "id", "-id", "created_at", "-created_at"}, v)

        countsAsPresent := app.getOptionalBoolQueryParameter(query, "counts_as_present", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "status", ""))

        statuses, metadata, err := app.models.AttendanceStatus.GetAll(name, countsAsPresent, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"attendance_statuses": statuses, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateAttendanceStatusHandler performs a partial update on an attendance status record.
//
//        @Summary                Update an attendance status
//        @Description        Perform a partial update on an attendance status record
//        @Tags                        attendance-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                        path                int                                                                true        "Attendance status ID"
//        @Param                        attendance_status        body                UpdateAttendanceStatusRequest_T        true        "Attendance status data"
//        @Success                200                                        {object}        envelope
//        @Failure                400                                        {object}        errorResponse
//        @Failure                404                                        {object}        errorResponse
//        @Failure                422                                        {object}        errorResponse
//        @Failure                500                                        {object}        errorResponse
//        @Router                        /v1/attendance/status/{id} [patch]
func (app *appDependencies) updateAttendanceStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.AttendanceStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateAttendanceStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateAttendanceStatusRequest.Status != nil </span><span class="cov0" title="0">{
                status.Status = *UpdateAttendanceStatusRequest.Status
        }</span>
        <span class="cov0" title="0">if UpdateAttendanceStatusRequest.CountsAsPresent != nil </span><span class="cov0" title="0">{
                status.CountsAsPresent = *UpdateAttendanceStatusRequest.CountsAsPresent
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateAttendanceStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.AttendanceStatus.Update(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "an attendance status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"attendance_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

/*********************** Progress Status ***********************/

// createProgressStatusHandler handles the creation of a new progress status.
//
//        @Summary                Create a new progress status
//        @Description        Create a new progress status
//        @Tags                        progress-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        progress_status        body                CreateProgressStatusRequest_T        true        "Progress status data"
//        @Success                201                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/progress/status [post]
func (app *appDependencies) createProgressStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := app.readJSON(w, r, &amp;CreateProgressStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">status := &amp;data.ProgressStatus{Status: CreateProgressStatusRequest.Status}

        v := validator.New()
        data.ValidateProgressStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.ProgressStatus.Insert(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "a progress status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/progress/status/%d", status.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"progress_status": status}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showProgressStatusHandler retrieves and returns a progress status by its ID.
//
//        @Summary                Get a progress status
//        @Description        Retrieve a progress status by its ID
//        @Tags                        progress-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "Progress status ID"
//        @Success                200        {object}        envelope
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/progress/status/{id} [get]
func (app *appDependencies) showProgressStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.ProgressStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"progress_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listProgressStatusesHandler returns a filtered list of progress statuses.
//
//        @Summary                List progress statuses
//        @Description        Retrieve a list of progress statuses with optional filtering
//        @Tags                        progress-statuses
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        status                query                string        false        "Filter by status name"
//        @Param                        page                query                int                false        "Page number for pagination"
//        @Param                        page_size        query                int                false        "Number of items per page"
//        @Param                        sort                query                string        false        "Sort order"
//        @Success                200                        {object}        envelope
//        @Failure                422                        {object}        errorResponse
//        @Failure                500                        {object}        errorResponse
//        @Router                        /v1/progress/status [get]
func (app *appDependencies) listProgressStatusesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "status", 20, []string{"status", "-status", "id", "-id", "created_at", "-created_at"}, v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">name := likeSearch(app.getSingleQueryParameter(query, "status", ""))

        statuses, metadata, err := app.models.ProgressStatus.GetAll(name, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"progress_statuses": statuses, "metadata": metadata}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateProgressStatusHandler performs a partial update on a progress status record.
//
//        @Summary                Update a progress status
//        @Description        Perform a partial update on a progress status record
//        @Tags                        progress-statuses
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id                                path                int                                                        true        "Progress status ID"
//        @Param                        progress_status        body                UpdateProgressStatusRequest_T        true        "Progress status data"
//        @Success                200                                {object}        envelope
//        @Failure                400                                {object}        errorResponse
//        @Failure                404                                {object}        errorResponse
//        @Failure                422                                {object}        errorResponse
//        @Failure                500                                {object}        errorResponse
//        @Router                        /v1/progress/status/{id} [patch]
func (app *appDependencies) updateProgressStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov0" title="0">status, err := app.models.ProgressStatus.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.readJSON(w, r, &amp;UpdateProgressStatusRequest); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">if UpdateProgressStatusRequest.Status != nil </span><span class="cov0" title="0">{
                status.Status = *UpdateProgressStatusRequest.Status
        }</span>

        <span class="cov0" title="0">v := validator.New()
        data.ValidateProgressStatus(v, status)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov0" title="0">if err := app.models.ProgressStatus.Update(status); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        v.AddError("status", "a progress status with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := app.writeJSON(w, http.StatusOK, envelope{"progress_status": status}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Filename: cmd/api/routes.go

package main

import (
        "expvar"
        "net/http"

        _ "github.com/Pedro-J-Kukul/police_training/docs"
        httpSwagger "github.com/swaggo/http-swagger"

        "github.com/julienschmidt/httprouter"
)

// routes sets up the HTTP routes for the application
func (app *appDependencies) routes() http.Handler <span class="cov0" title="0">{
        router := httprouter.New() // create a new router instance

        // Error handling for unsupported methods
        router.NotFound = http.HandlerFunc(app.notFoundResponse)
        router.MethodNotAllowed = http.HandlerFunc(app.methodNotAllowedResponse)

        router.Handler(http.MethodGet, "/swagger/:any", httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"), //The url pointing to API definition
        ))
        // Health and observability
        router.HandlerFunc(http.MethodGet, "/v1/healthcheck", app.healthCheckHandler)
        router.Handler(http.MethodGet, "/v1/observability/metrics", expvar.Handler())

        // Authentication and user lifecycle (no permissions required)
        router.HandlerFunc(http.MethodPost, "/v1/users", app.registerUserHandler)
        router.HandlerFunc(http.MethodPut, "/v1/users/activate", app.activateUserHandler)
        router.HandlerFunc(http.MethodPost, "/v1/tokens/authentication", app.createAuthenticationTokenHandler)
        router.HandlerFunc(http.MethodPost, "/v1/tokens/password-reset", app.createPasswordResetTokenHandler)
        router.HandlerFunc(http.MethodPut, "/v1/users/password-reset", app.resetPasswordHandler)

        // Authenticated user endpoints
        router.Handler(http.MethodGet, "/v1/me", app.requireActivatedUser(http.HandlerFunc(app.showCurrentUserHandler)))
        router.Handler(http.MethodGet, "/v1/users", app.requirePermissions("users:view")(http.HandlerFunc(app.listUsersHandler)))
        router.Handler(http.MethodGet, "/v1/users/:id", app.requirePermissions("users:view")(http.HandlerFunc(app.showUserHandler)))
        router.Handler(http.MethodPatch, "/v1/users/:id", app.requirePermissions("users:edit")(http.HandlerFunc(app.updateUserHandler)))
        router.Handler(http.MethodDelete, "/v1/users/:id", app.requirePermissions("users:delete")(http.HandlerFunc(app.deleteUserHandler)))

        // ------------------ Domain-specific routes (standardized) ----------------------

        // Workshop routes
        router.Handler(http.MethodPost, "/v1/workshops", app.requirePermissions("workshops:create")(http.HandlerFunc(app.createWorkshopHandler)))
        router.Handler(http.MethodGet, "/v1/workshops", app.requirePermissions("workshops:view")(http.HandlerFunc(app.listWorkshopsHandler)))
        router.Handler(http.MethodGet, "/v1/workshops/:id", app.requirePermissions("workshops:view")(http.HandlerFunc(app.showWorkshopHandler)))
        router.Handler(http.MethodPatch, "/v1/workshops/:id", app.requirePermissions("workshops:edit")(http.HandlerFunc(app.updateWorkshopHandler)))

        // Training Categories routes
        router.Handler(http.MethodPost, "/v1/training/categories", app.requirePermissions("training:categories:create")(http.HandlerFunc(app.createTrainingCategoryHandler)))
        router.Handler(http.MethodGet, "/v1/training/categories", app.requirePermissions("training:categories:view")(http.HandlerFunc(app.listTrainingCategoriesHandler)))
        router.Handler(http.MethodGet, "/v1/training/categories/:id", app.requirePermissions("training:categories:view")(http.HandlerFunc(app.showTrainingCategoryHandler)))
        router.Handler(http.MethodPatch, "/v1/training/categories/:id", app.requirePermissions("training:categories:edit")(http.HandlerFunc(app.updateTrainingCategoryHandler)))

        // Training Types routes
        router.Handler(http.MethodPost, "/v1/training/types", app.requirePermissions("training:types:create")(http.HandlerFunc(app.createTrainingTypeHandler)))
        router.Handler(http.MethodGet, "/v1/training/types", app.requirePermissions("training:types:view")(http.HandlerFunc(app.listTrainingTypesHandler)))
        router.Handler(http.MethodGet, "/v1/training/types/:id", app.requirePermissions("training:types:view")(http.HandlerFunc(app.showTrainingTypeHandler)))
        router.Handler(http.MethodPatch, "/v1/training/types/:id", app.requirePermissions("training:types:edit")(http.HandlerFunc(app.updateTrainingTypeHandler)))

        // Training Status routes
        router.Handler(http.MethodPost, "/v1/training/status", app.requirePermissions("training:status:create")(http.HandlerFunc(app.createTrainingStatusHandler)))
        router.Handler(http.MethodGet, "/v1/training/status/:id", app.requirePermissions("training:status:view")(http.HandlerFunc(app.showTrainingStatusHandler)))
        router.Handler(http.MethodPatch, "/v1/training/status/:id", app.requirePermissions("training:status:edit")(http.HandlerFunc(app.updateTrainingStatusHandler)))
        router.Handler(http.MethodGet, "/v1/training/status", app.requirePermissions("training:status:view")(http.HandlerFunc(app.getTrainingStatusesHandler)))

        // Enrollment Status routes
        router.Handler(http.MethodPost, "/v1/enrollment/status", app.requirePermissions("enrollment:status:create")(http.HandlerFunc(app.createEnrollmentStatusHandler)))
        router.Handler(http.MethodGet, "/v1/enrollment/status", app.requirePermissions("enrollment:status:view")(http.HandlerFunc(app.listEnrollmentStatusesHandler)))
        router.Handler(http.MethodGet, "/v1/enrollment/status/:id", app.requirePermissions("enrollment:status:view")(http.HandlerFunc(app.showEnrollmentStatusHandler)))
        router.Handler(http.MethodPatch, "/v1/enrollment/status/:id", app.requirePermissions("enrollment:status:edit")(http.HandlerFunc(app.updateEnrollmentStatusHandler)))

        // Attendance Status routes
        router.Handler(http.MethodPost, "/v1/attendance/status", app.requirePermissions("attendance:status:create")(http.HandlerFunc(app.createAttendanceStatusHandler)))
        router.Handler(http.MethodGet, "/v1/attendance/status", app.requirePermissions("attendance:status:view")(http.HandlerFunc(app.listAttendanceStatusesHandler)))
        router.Handler(http.MethodGet, "/v1/attendance/status/:id", app.requirePermissions("attendance:status:view")(http.HandlerFunc(app.showAttendanceStatusHandler)))
        router.Handler(http.MethodPatch, "/v1/attendance/status/:id", app.requirePermissions("attendance:status:edit")(http.HandlerFunc(app.updateAttendanceStatusHandler)))

        // Progress Status routes
        router.Handler(http.MethodPost, "/v1/progress/status", app.requirePermissions("progress:status:create")(http.HandlerFunc(app.createProgressStatusHandler)))
        router.Handler(http.MethodGet, "/v1/progress/status", app.requirePermissions("progress:status:view")(http.HandlerFunc(app.listProgressStatusesHandler)))
        router.Handler(http.MethodGet, "/v1/progress/status/:id", app.requirePermissions("progress:status:view")(http.HandlerFunc(app.showProgressStatusHandler)))
        router.Handler(http.MethodPatch, "/v1/progress/status/:id", app.requirePermissions("progress:status:edit")(http.HandlerFunc(app.updateProgressStatusHandler)))

        // Postings routes
        router.Handler(http.MethodPost, "/v1/postings", app.requirePermissions("postings:create")(http.HandlerFunc(app.createPostingHandler)))
        router.Handler(http.MethodGet, "/v1/postings", app.requirePermissions("postings:view")(http.HandlerFunc(app.listPostingsHandler)))
        router.Handler(http.MethodGet, "/v1/postings/:id", app.requirePermissions("postings:view")(http.HandlerFunc(app.showPostingHandler)))
        router.Handler(http.MethodPatch, "/v1/postings/:id", app.requirePermissions("postings:edit")(http.HandlerFunc(app.updatePostingHandler)))

        // Ranks routes
        router.Handler(http.MethodPost, "/v1/ranks", app.requirePermissions("ranks:create")(http.HandlerFunc(app.createRankHandler)))
        router.Handler(http.MethodGet, "/v1/ranks", app.requirePermissions("ranks:view")(http.HandlerFunc(app.listRanksHandler)))
        router.Handler(http.MethodGet, "/v1/ranks/:id", app.requirePermissions("ranks:view")(http.HandlerFunc(app.showRankHandler)))
        router.Handler(http.MethodPatch, "/v1/ranks/:id", app.requirePermissions("ranks:edit")(http.HandlerFunc(app.updateRankHandler)))

        // Regions routes
        router.Handler(http.MethodPost, "/v1/regions", app.requirePermissions("regions:create")(http.HandlerFunc(app.createRegionHandler)))
        router.Handler(http.MethodGet, "/v1/regions", app.requirePermissions("regions:view")(http.HandlerFunc(app.listRegionsHandler)))
        router.Handler(http.MethodGet, "/v1/regions/:id", app.requirePermissions("regions:view")(http.HandlerFunc(app.showRegionHandler)))
        router.Handler(http.MethodPatch, "/v1/regions/:id", app.requirePermissions("regions:edit")(http.HandlerFunc(app.updateRegionHandler)))

        // Formations routes
        router.Handler(http.MethodPost, "/v1/formations", app.requirePermissions("formations:create")(http.HandlerFunc(app.createFormationHandler)))
        router.Handler(http.MethodGet, "/v1/formations", app.requirePermissions("formations:view")(http.HandlerFunc(app.listFormationsHandler)))
        router.Handler(http.MethodGet, "/v1/formations/:id", app.requirePermissions("formations:view")(http.HandlerFunc(app.showFormationHandler)))
        router.Handler(http.MethodPatch, "/v1/formations/:id", app.requirePermissions("formations:edit")(http.HandlerFunc(app.updateFormationHandler)))

        // Officer routes
        router.Handler(http.MethodPost, "/v1/officers", app.requirePermissions("officers:create")(http.HandlerFunc(app.createOfficerHandler)))
        router.Handler(http.MethodGet, "/v1/officers", app.requirePermissions("officers:view")(http.HandlerFunc(app.listOfficersHandler)))
        router.Handler(http.MethodGet, "/v1/officers/:id", app.requirePermissions("officers:view")(http.HandlerFunc(app.showOfficerHandler)))
        router.Handler(http.MethodGet, "/v1/officers/:id/details", app.requirePermissions("officers:view")(http.HandlerFunc(app.showOfficerWithDetailsHandler)))
        router.Handler(http.MethodPatch, "/v1/officers/:id", app.requirePermissions("officers:edit")(http.HandlerFunc(app.updateOfficerHandler)))
        router.Handler(http.MethodDelete, "/v1/officers/:id", app.requirePermissions("officers:delete")(http.HandlerFunc(app.deleteOfficerHandler)))

        // User-Officer relationship routes
        router.Handler(http.MethodGet, "/v1/users/:id/officer", app.requirePermissions("officers:view")(http.HandlerFunc(app.getUserOfficerHandler)))

        // Training sessions routes
        router.Handler(http.MethodPost, "/v1/training/sessions", app.requirePermissions("training:sessions:create")(http.HandlerFunc(app.createTrainingSessionHandler)))
        router.Handler(http.MethodGet, "/v1/training/sessions", app.requirePermissions("training:sessions:view")(http.HandlerFunc(app.listTrainingSessionsHandler)))
        router.Handler(http.MethodGet, "/v1/training/sessions/:id", app.requirePermissions("training:sessions:view")(http.HandlerFunc(app.showTrainingSessionHandler)))
        router.Handler(http.MethodPatch, "/v1/training/sessions/:id", app.requirePermissions("training:sessions:edit")(http.HandlerFunc(app.updateTrainingSessionHandler)))
        router.Handler(http.MethodDelete, "/v1/training/sessions/:id", app.requirePermissions("training:sessions:delete")(http.HandlerFunc(app.deleteTrainingSessionHandler)))

        // Training enrollments routes
        router.Handler(http.MethodPost, "/v1/training/enrollments", app.requirePermissions("training:enrollments:create")(http.HandlerFunc(app.createTrainingEnrollmentHandler)))
        router.Handler(http.MethodGet, "/v1/training/enrollments", app.requirePermissions("training:enrollments:view")(http.HandlerFunc(app.listTrainingEnrollmentsHandler)))
        router.Handler(http.MethodGet, "/v1/training/enrollments/:id", app.requirePermissions("training:enrollments:view")(http.HandlerFunc(app.showTrainingEnrollmentHandler)))
        router.Handler(http.MethodPatch, "/v1/training/enrollments/:id", app.requirePermissions("training:enrollments:edit")(http.HandlerFunc(app.updateTrainingEnrollmentHandler)))
        router.Handler(http.MethodDelete, "/v1/training/enrollments/:id", app.requirePermissions("training:enrollments:delete")(http.HandlerFunc(app.deleteTrainingEnrollmentHandler)))

        return app.recoverPanic(app.enableCORS(app.metrics(app.rateLimit(app.authenticate(router)))))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Filename: cmd/api/server.go
package main

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
)

// serve starts the HTTP server and listens for incoming requests
func (app *appDependencies) serve() error <span class="cov0" title="0">{

        // Define the server configuration
        srv := &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", app.config.port),                      // server address with port
                Handler:      app.routes(),                                             // HTTP handler for routing requests
                IdleTimeout:  1 * time.Minute,                                          // maximum idle time for connections
                ReadTimeout:  5 * time.Second,                                          // maximum duration for reading the request
                WriteTimeout: 10 * time.Second,                                         // maximum duration for writing the response
                ErrorLog:     slog.NewLogLogger(app.logger.Handler(), slog.LevelError), // custom error logger
        }

        shutdown := make(chan error) // channel for shutdown errors

        // Start a goroutine to listen for shutdown signals
        go func() </span><span class="cov0" title="0">{
                quit := make(chan os.Signal, 1)                                              // channel for OS signals
                signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)                         // listen for interrupt and terminate signals
                sig := &lt;-quit                                                                // block until a signal is received
                app.logger.Info("shutting down server", slog.String("signal", sig.String())) // log the shutdown signal

                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) // context with timeout for shutdown
                defer cancel()                                                           // ensure the context is cancelled to free resources

                err := srv.Shutdown(ctx) // attempt to gracefully shutdown the server
                if err != nil </span><span class="cov0" title="0">{
                        shutdown &lt;- err // send any shutdown error to the channel
                }</span>

                <span class="cov0" title="0">app.logger.Info("completing background tasks") // log completion of background tasks
                app.wg.Wait()                                  // wait for all background tasks to complete
                shutdown &lt;- nil</span>                                // signal that shutdown is complete
        }()

        <span class="cov0" title="0">app.logger.Info("starting server", slog.String("env", app.config.env), slog.Int("port", app.config.port)) // log server start

        err := srv.ListenAndServe()                // start the server and listen for requests
        if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{ // check if the error is not due to server shutdown
                return err // return any unexpected error
        }</span>

        <span class="cov0" title="0">err = &lt;-shutdown // wait for shutdown to complete
        if err != nil </span><span class="cov0" title="0">{
                return err // return any shutdown error
        }</span>

        <span class="cov0" title="0">app.logger.Info("server stopped") // log that the server has stopped
        return nil</span>                        // return nil indicating successful shutdown
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "context"
        "net/http"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/julienschmidt/httprouter"
)

// Test helper to simulate httprouter parameter extraction
func setURLParam(r *http.Request, key, value string) *http.Request <span class="cov8" title="1">{
        ctx := r.Context()
        params := httprouter.Params{httprouter.Param{Key: key, Value: value}}
        ctx = context.WithValue(ctx, httprouter.ParamsKey, params)
        return r.WithContext(ctx)
}</span>

// Test helper to simulate user context
func setUserContext(r *http.Request, user *data.User) *http.Request <span class="cov8" title="1">{
        ctx := context.WithValue(r.Context(), contextKeyUser, user)
        return r.WithContext(ctx)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// FileName: cmd/api/tokens.go
package main

import (
        "errors"
        "net/http"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

// createAuthenticationTokenHandler handles the creation of authentication tokens.
//
//        @Summary                Create Authentication Token
//        @Description        Generates an authentication token for a user based on provided email and password.
//        @Tags                        Tokens
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                CreateAuthenticationTokenRequest_T        true        "User credentials"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/tokens/authentication [post]
func (app *appDependencies) createAuthenticationTokenHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // incomingData struct to hold the incoming JSON data
        var incomingData struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }

        // Read and parse the JSON request body
        if err := app.readJSON(w, r, &amp;incomingData); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        // Validate the incoming data
        <span class="cov8" title="1">v := validator.New() // declare a new validator instance

        data.ValidateEmail(v, incomingData.Email)                // validate the email field
        data.ValidatePasswordPlaintext(v, incomingData.Password) // validate the password field

        // If any validation errors, send a 422 Unprocessable Entity response
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        // Authenticate the user
        <span class="cov8" title="1">user, err := app.models.User.GetByEmail(incomingData.Email)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.invalidCredentialsResponse(w, r)</span> // invalid credentials
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span> // other errors
                }
                <span class="cov8" title="1">return</span>
        }

        // Check if the user is activated and isn't trying to bypass the flow
        <span class="cov8" title="1">if !user.IsActivated </span><span class="cov0" title="0">{
                v.AddError("email", "account must be activated to login")
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        // Check if the provided password matches the stored password
        <span class="cov8" title="1">match, err := user.Password.Matches(incomingData.Password)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        // If the passwords don't match, send an invalid credentials response
        <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                app.invalidCredentialsResponse(w, r)
                return
        }</span>

        // Generate and return the authentication token
        <span class="cov8" title="1">token, err := app.models.Token.New(user.ID, 24*time.Hour, data.ScopeAuthentication)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">data := envelope{"authentication_token": token}       // wrap the token in an envelope
        err = app.writeJSON(w, http.StatusCreated, data, nil) // send a 201 Created response
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err) // handle any errors
        }</span>
}

// createPasswordResetTokenHandler sends a password reset token to the user's email.
//
//        @Summary                Create Password Reset Token
//        @Description        Generates a password reset token and sends it to the user's email address.
//        @Tags                        Tokens
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                CreatePasswordResetTokenRequest_T        true        "User email"
//        @Success                202                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/tokens/password-reset [post]
func (app *appDependencies) createPasswordResetTokenHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                Email string `json:"email"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateEmail(v, input.Email)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.GetByEmail(input.Email)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        if err := app.writeJSON(w, http.StatusAccepted, envelope{"message": "if that account exists, a password reset email has been sent"}, nil); err != nil </span><span class="cov0" title="0">{
                                app.serverErrorResponse(w, r, err)
                        }</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        // Check if the user is activated and isn't trying to bypass the flow
        <span class="cov8" title="1">if !user.IsActivated </span><span class="cov0" title="0">{
                v.AddError("email", "account must be activated to reset password")
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">_ = app.models.Token.DeleteAllForUser(data.ScopePasswordReset, user.ID)

        token, err := app.models.Token.New(user.ID, 45*time.Minute, data.ScopePasswordReset)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if app.mailer != nil </span><span class="cov0" title="0">{
                app.background(func() </span><span class="cov0" title="0">{
                        payload := map[string]any{
                                "resetToken": token.Plaintext,
                                "userID":     user.ID,
                        }
                        if err := app.mailer.Send(user.Email, "password_reset.tmpl", payload); err != nil </span><span class="cov0" title="0">{
                                app.logger.Error("failed to send password reset email", "error", err)
                        }</span>
                })
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusAccepted, envelope{"message": "if that account exists, a password reset email has been sent"}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// resetPasswordHandler updates a user's password using a reset token.
//
//        @Summary                Reset Password
//        @Description        Resets a user's password using a valid password reset token.
//        @Tags                        Tokens
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                ResetPasswordRequest_T        true        "Password reset data"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/users/password-reset [put]
func (app *appDependencies) resetPasswordHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                Token    string `json:"token"`
                Password string `json:"password"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateTokenPlaintext(v, input.Token)
        data.ValidatePasswordPlaintext(v, input.Password)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.GetForToken(data.ScopePasswordReset, input.Token)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        v.AddError("token", "invalid or expired password reset token")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if err := user.Password.Set(input.Password); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.User.Update(user); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrEditConflict):<span class="cov0" title="0">
                        app.editConflictResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if err := app.models.Token.DeleteAllForUser(data.ScopePasswordReset, user.ID); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.Token.DeleteAllForUser(data.ScopeAuthentication, user.ID); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"message": "password updated"}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

func (app *appDependencies) createTrainingEnrollmentHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                OfficerID          int64   `json:"officer_id"`
                SessionID          int64   `json:"session_id"`
                EnrollmentStatusID int64   `json:"enrollment_status_id"`
                AttendanceStatusID *int64  `json:"attendance_status_id"`
                ProgressStatusID   int64   `json:"progress_status_id"`
                CompletionDate     *string `json:"completion_date"` // "2025-01-15"
                CertificateIssued  *bool   `json:"certificate_issued"`
                CertificateNumber  *string `json:"certificate_number"`
        }

        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">enrollment := &amp;data.TrainingEnrollment{
                OfficerID:          input.OfficerID,
                SessionID:          input.SessionID,
                EnrollmentStatusID: input.EnrollmentStatusID,
                AttendanceStatusID: input.AttendanceStatusID,
                ProgressStatusID:   input.ProgressStatusID,
                CertificateIssued:  false, // default
                CertificateNumber:  input.CertificateNumber,
        }

        if input.CertificateIssued != nil </span><span class="cov8" title="1">{
                enrollment.CertificateIssued = *input.CertificateIssued
        }</span>

        // Parse completion date if provided
        <span class="cov8" title="1">if input.CompletionDate != nil </span><span class="cov8" title="1">{
                completionDate, err := time.Parse("2006-01-02", *input.CompletionDate)
                if err != nil </span><span class="cov8" title="1">{
                        app.badRequestResponse(w, r, errors.New("invalid completion_date format, use YYYY-MM-DD"))
                        return
                }</span>
                <span class="cov0" title="0">enrollment.CompletionDate = &amp;completionDate</span>
        }

        <span class="cov8" title="1">v := validator.New()
        data.ValidateTrainingEnrollment(v, enrollment)

        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingEnrollment.Insert(enrollment)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("officer is already enrolled in this session"))</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov8" title="1">
                        app.badRequestResponse(w, r, errors.New("invalid officer_id, session_id, enrollment_status_id, or progress_status_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/training-enrollments/%d", enrollment.ID))

        err = app.writeJSON(w, http.StatusCreated, envelope{"training_enrollment": enrollment}, headers)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) showTrainingEnrollmentHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">enrollment, err := app.models.TrainingEnrollment.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_enrollment": enrollment}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) listTrainingEnrollmentsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "created_at", 20, []string{"created_at", "-created_at", "id", "-id", "completion_date", "-completion_date"}, v)

        officerID := app.getOptionalInt64QueryParameter(query, "officer_id", v)
        sessionID := app.getOptionalInt64QueryParameter(query, "session_id", v)
        enrollmentStatusID := app.getOptionalInt64QueryParameter(query, "enrollment_status_id", v)
        attendanceStatusID := app.getOptionalInt64QueryParameter(query, "attendance_status_id", v)
        progressStatusID := app.getOptionalInt64QueryParameter(query, "progress_status_id", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">enrollments, metadata, err := app.models.TrainingEnrollment.GetAll(officerID, sessionID, enrollmentStatusID, attendanceStatusID, progressStatusID, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_enrollments": enrollments, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) updateTrainingEnrollmentHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">enrollment, err := app.models.TrainingEnrollment.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                OfficerID          *int64  `json:"officer_id"`
                SessionID          *int64  `json:"session_id"`
                EnrollmentStatusID *int64  `json:"enrollment_status_id"`
                AttendanceStatusID *int64  `json:"attendance_status_id"`
                ProgressStatusID   *int64  `json:"progress_status_id"`
                CompletionDate     *string `json:"completion_date"`
                CertificateIssued  *bool   `json:"certificate_issued"`
                CertificateNumber  *string `json:"certificate_number"`
        }

        err = app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if input.OfficerID != nil </span><span class="cov0" title="0">{
                enrollment.OfficerID = *input.OfficerID
        }</span>
        <span class="cov8" title="1">if input.SessionID != nil </span><span class="cov0" title="0">{
                enrollment.SessionID = *input.SessionID
        }</span>
        <span class="cov8" title="1">if input.EnrollmentStatusID != nil </span><span class="cov0" title="0">{
                enrollment.EnrollmentStatusID = *input.EnrollmentStatusID
        }</span>
        <span class="cov8" title="1">if input.AttendanceStatusID != nil </span><span class="cov0" title="0">{
                enrollment.AttendanceStatusID = input.AttendanceStatusID
        }</span>
        <span class="cov8" title="1">if input.ProgressStatusID != nil </span><span class="cov8" title="1">{
                enrollment.ProgressStatusID = *input.ProgressStatusID
        }</span>
        <span class="cov8" title="1">if input.CompletionDate != nil </span><span class="cov8" title="1">{
                if *input.CompletionDate == "" </span><span class="cov0" title="0">{
                        enrollment.CompletionDate = nil
                }</span> else<span class="cov8" title="1"> {
                        completionDate, err := time.Parse("2006-01-02", *input.CompletionDate)
                        if err != nil </span><span class="cov8" title="1">{
                                app.badRequestResponse(w, r, errors.New("invalid completion_date format, use YYYY-MM-DD"))
                                return
                        }</span>
                        <span class="cov8" title="1">enrollment.CompletionDate = &amp;completionDate</span>
                }
        }
        <span class="cov8" title="1">if input.CertificateIssued != nil </span><span class="cov8" title="1">{
                enrollment.CertificateIssued = *input.CertificateIssued
        }</span>
        <span class="cov8" title="1">if input.CertificateNumber != nil </span><span class="cov8" title="1">{
                enrollment.CertificateNumber = input.CertificateNumber
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateTrainingEnrollment(v, enrollment)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingEnrollment.Update(enrollment)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("officer is already enrolled in this session"))</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("invalid officer_id, session_id, enrollment_status_id, or progress_status_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_enrollment": enrollment}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) deleteTrainingEnrollmentHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingEnrollment.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"message": "training enrollment successfully deleted"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// Specialized handlers
func (app *appDependencies) getOfficerEnrollmentsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">query := r.URL.Query()
        v := validator.New()
        filters := app.readFilters(query, "created_at", 20, []string{"created_at", "-created_at", "completion_date", "-completion_date"}, v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">enrollments, metadata, err := app.models.TrainingEnrollment.GetByOfficer(id, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_enrollments": enrollments, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) getSessionEnrollmentsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">query := r.URL.Query()
        v := validator.New()
        filters := app.readFilters(query, "created_at", 20, []string{"created_at", "-created_at", "completion_date", "-completion_date"}, v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">enrollments, metadata, err := app.models.TrainingEnrollment.GetBySession(id, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_enrollments": enrollments, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) issueCertificateHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">var input struct {
                CertificateNumber string `json:"certificate_number"`
                CompletionDate    string `json:"completion_date"` // "2025-01-15"
        }

        err = app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        // Validate inputs
        <span class="cov8" title="1">v := validator.New()
        v.Check(input.CertificateNumber != "", "certificate_number", "must be provided")
        v.Check(len(input.CertificateNumber) &lt;= 100, "certificate_number", "must not exceed 100 characters")
        v.Check(input.CompletionDate != "", "completion_date", "must be provided")

        completionDate, err := time.Parse("2006-01-02", input.CompletionDate)
        if err != nil </span><span class="cov8" title="1">{
                v.AddError("completion_date", "invalid date format, use YYYY-MM-DD")
        }</span>

        <span class="cov8" title="1">if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingEnrollment.IssueCertificate(id, input.CertificateNumber, completionDate)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"message": "certificate issued successfully"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

func (app *appDependencies) createTrainingSessionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                FacilitatorID    int64   `json:"facilitator_id"`
                WorkshopID       int64   `json:"workshop_id"`
                FormationID      int64   `json:"formation_id"`
                RegionID         int64   `json:"region_id"`
                SessionDate      string  `json:"session_date"` // "2025-01-15"
                StartTime        string  `json:"start_time"`   // "09:00"
                EndTime          string  `json:"end_time"`     // "17:00"
                Location         *string `json:"location"`
                MaxCapacity      *int    `json:"max_capacity"`
                TrainingStatusID int64   `json:"training_status_id"`
                Notes            *string `json:"notes"`
        }

        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        // Parse date and times
        <span class="cov8" title="1">sessionDate, err := time.Parse("2006-01-02", input.SessionDate)
        if err != nil </span><span class="cov8" title="1">{
                app.badRequestResponse(w, r, errors.New("invalid session_date format, use YYYY-MM-DD"))
                return
        }</span>

        <span class="cov8" title="1">startTime, err := time.Parse("15:04", input.StartTime)
        if err != nil </span><span class="cov8" title="1">{
                app.badRequestResponse(w, r, errors.New("invalid start_time format, use HH:MM"))
                return
        }</span>

        <span class="cov8" title="1">endTime, err := time.Parse("15:04", input.EndTime)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, errors.New("invalid end_time format, use HH:MM"))
                return
        }</span>

        <span class="cov8" title="1">session := &amp;data.TrainingSession{
                FacilitatorID:    input.FacilitatorID,
                WorkshopID:       input.WorkshopID,
                FormationID:      input.FormationID,
                RegionID:         input.RegionID,
                SessionDate:      sessionDate,
                StartTime:        startTime,
                EndTime:          endTime,
                Location:         input.Location,
                MaxCapacity:      input.MaxCapacity,
                TrainingStatusID: input.TrainingStatusID,
                Notes:            input.Notes,
        }

        v := validator.New()
        data.ValidateTrainingSession(v, session)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingSession.Insert(session)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("a training session with these details already exists"))</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("invalid facilitator_id, workshop_id, formation_id, region_id, or training_status_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/training-sessions/%d", session.ID))

        err = app.writeJSON(w, http.StatusCreated, envelope{"training_session": session}, headers)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) showTrainingSessionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">session, err := app.models.TrainingSession.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_session": session}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) listTrainingSessionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "session_date", 20, []string{"session_date", "-session_date", "id", "-id", "start_time", "-start_time", "created_at", "-created_at"}, v)

        facilitatorID := app.getOptionalInt64QueryParameter(query, "facilitator_id", v)
        workshopID := app.getOptionalInt64QueryParameter(query, "workshop_id", v)
        formationID := app.getOptionalInt64QueryParameter(query, "formation_id", v)
        regionID := app.getOptionalInt64QueryParameter(query, "region_id", v)
        statusID := app.getOptionalInt64QueryParameter(query, "training_status_id", v)

        var sessionDate *time.Time
        sessionDateStr := app.getSingleQueryParameter(query, "session_date", "")
        if sessionDateStr != "" </span><span class="cov8" title="1">{
                parsedDate, err := time.Parse("2006-01-02", sessionDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        v.AddError("session_date", "invalid date format, use YYYY-MM-DD")
                }</span> else<span class="cov8" title="1"> {
                        sessionDate = &amp;parsedDate
                }</span>
        }

        <span class="cov8" title="1">if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">sessions, metadata, err := app.models.TrainingSession.GetAll(facilitatorID, workshopID, formationID, regionID, statusID, sessionDate, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_sessions": sessions, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) updateTrainingSessionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">session, err := app.models.TrainingSession.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                FacilitatorID    *int64  `json:"facilitator_id"`
                WorkshopID       *int64  `json:"workshop_id"`
                FormationID      *int64  `json:"formation_id"`
                RegionID         *int64  `json:"region_id"`
                SessionDate      *string `json:"session_date"`
                StartTime        *string `json:"start_time"`
                EndTime          *string `json:"end_time"`
                Location         *string `json:"location"`
                MaxCapacity      *int    `json:"max_capacity"`
                TrainingStatusID *int64  `json:"training_status_id"`
                Notes            *string `json:"notes"`
        }

        err = app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if input.FacilitatorID != nil </span><span class="cov0" title="0">{
                session.FacilitatorID = *input.FacilitatorID
        }</span>
        <span class="cov8" title="1">if input.WorkshopID != nil </span><span class="cov0" title="0">{
                session.WorkshopID = *input.WorkshopID
        }</span>
        <span class="cov8" title="1">if input.FormationID != nil </span><span class="cov0" title="0">{
                session.FormationID = *input.FormationID
        }</span>
        <span class="cov8" title="1">if input.RegionID != nil </span><span class="cov0" title="0">{
                session.RegionID = *input.RegionID
        }</span>
        <span class="cov8" title="1">if input.SessionDate != nil </span><span class="cov8" title="1">{
                sessionDate, err := time.Parse("2006-01-02", *input.SessionDate)
                if err != nil </span><span class="cov8" title="1">{
                        app.badRequestResponse(w, r, errors.New("invalid session_date format, use YYYY-MM-DD"))
                        return
                }</span>
                <span class="cov0" title="0">session.SessionDate = sessionDate</span>
        }
        <span class="cov8" title="1">if input.StartTime != nil </span><span class="cov0" title="0">{
                startTime, err := time.Parse("15:04", *input.StartTime)
                if err != nil </span><span class="cov0" title="0">{
                        app.badRequestResponse(w, r, errors.New("invalid start_time format, use HH:MM"))
                        return
                }</span>
                <span class="cov0" title="0">session.StartTime = startTime</span>
        }
        <span class="cov8" title="1">if input.EndTime != nil </span><span class="cov0" title="0">{
                endTime, err := time.Parse("15:04", *input.EndTime)
                if err != nil </span><span class="cov0" title="0">{
                        app.badRequestResponse(w, r, errors.New("invalid end_time format, use HH:MM"))
                        return
                }</span>
                <span class="cov0" title="0">session.EndTime = endTime</span>
        }
        <span class="cov8" title="1">if input.Location != nil </span><span class="cov8" title="1">{
                session.Location = input.Location
        }</span>
        <span class="cov8" title="1">if input.MaxCapacity != nil </span><span class="cov8" title="1">{
                session.MaxCapacity = input.MaxCapacity
        }</span>
        <span class="cov8" title="1">if input.TrainingStatusID != nil </span><span class="cov0" title="0">{
                session.TrainingStatusID = *input.TrainingStatusID
        }</span>
        <span class="cov8" title="1">if input.Notes != nil </span><span class="cov8" title="1">{
                session.Notes = input.Notes
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateTrainingSession(v, session)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingSession.Update(session)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("a training session with these details already exists"))</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov0" title="0">
                        app.badRequestResponse(w, r, errors.New("invalid facilitator_id, workshop_id, formation_id, region_id, or training_status_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"training_session": session}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) deleteTrainingSessionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.TrainingSession.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"message": "training session successfully deleted"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

// registerUserHandler creates a new user account and sends an activation email.
//
//        @Summary                Register a new user
//        @Description        Create a new user account and send an activation email
//        @Tags                        users
//        @Accept                        json
//        @Produce                json
//        @Param                        user        body                registerUserRequest        true        "User registration data"
//        @Success                201                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/users [post]
func (app *appDependencies) registerUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                FirstName     string `json:"first_name"`
                LastName      string `json:"last_name"`
                Email         string `json:"email"`
                Gender        string `json:"gender"`
                Password      string `json:"password"`
                IsFacilitator bool   `json:"is_facilitator"`
                IsOfficer     bool   `json:"is_officer"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">user := &amp;data.User{
                FirstName:     input.FirstName,
                LastName:      input.LastName,
                Email:         input.Email,
                Gender:        input.Gender,
                IsActivated:   false,
                IsFacilitator: input.IsFacilitator,
                IsOfficer:     input.IsOfficer,
        }

        if err := user.Password.Set(input.Password); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateUser(v, user)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.User.Insert(user); err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateEmail):<span class="cov8" title="1">
                        v.AddError("email", "a user with this email already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>

        }

        // Make user an officer by default roles
        <span class="cov8" title="1">err := app.models.Role.AssignToUser(user.ID, "Officer")
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        // Always clear existing activation tokens and send a new one.
        <span class="cov8" title="1">_ = app.models.Token.DeleteAllForUser(data.ScopeActivation, user.ID)
        activationToken, err := app.models.Token.New(user.ID, 72*time.Hour, data.ScopeActivation)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err) // Log the error and return a server error response
                return
        }</span>

        <span class="cov8" title="1">if app.mailer != nil </span><span class="cov0" title="0">{
                app.background(func() </span><span class="cov0" title="0">{
                        data := map[string]any{
                                "userID":          user.ID,
                                "firstName":       user.FirstName,
                                "lastName":        user.LastName,
                                "email":           user.Email,
                                "password":        input.Password,
                                "activationToken": activationToken.Plaintext,
                        }
                        if err := app.mailer.Send(user.Email, "user_welcome.tmpl", data); err != nil </span><span class="cov0" title="0">{
                                app.logger.Error("failed to send activation email", "error", err)
                        }</span>
                })
        }

        <span class="cov8" title="1">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/users/%d", user.ID))

        if err := app.writeJSON(w, http.StatusCreated, envelope{"user": user}, headers); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// activateUserHandler uses an activation token to activate a pending account.
//
//        @Summary                Activate a user account
//        @Description        Activate a user account using an activation token
//        @Tags                        users
//        @Accept                        json
//        @Produce                json
//        @Param                        token        body                activateUserRequest        true        "Activation token"
//        @Success                200                {object}        envelope
//        @Failure                400                {object}        errorResponse
//        @Failure                422                {object}        errorResponse
//        @Failure                500                {object}        errorResponse
//        @Router                        /v1/users/activate [put]
func (app *appDependencies) activateUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                Token string `json:"token"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateTokenPlaintext(v, input.Token)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.GetForToken(data.ScopeActivation, input.Token)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        v.AddError("token", "invalid or expired activation token")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">user.IsActivated = true

        if err := app.models.User.Update(user); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrEditConflict):<span class="cov0" title="0">
                        app.editConflictResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if err := app.models.Token.DeleteAllForUser(data.ScopeActivation, user.ID); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"user": user}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showCurrentUserHandler returns the user record associated with the request context.
//
//        @Summary                Get current user
//        @Description        Retrieve the user record associated with the current request context
//        @Tags                        users
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Success                200        {object}        envelope
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/me [get]
func (app *appDependencies) showCurrentUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        user := app.contextGetUser(r)
        if err := app.writeJSON(w, http.StatusOK, envelope{"user": user}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// showUserHandler returns a user by id.
func (app *appDependencies) showUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := app.writeJSON(w, http.StatusOK, envelope{"user": user}, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// listUsersHandler returns a filtered list of users.
//
//        @Summary                List users
//        @Description        Retrieve a list of users with optional filters and pagination
//        @Tags                        users
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Success                200        {object}        envelope
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/users [get]
func (app *appDependencies) listUsersHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        v := validator.New()

        filters := data.Filters{
                Page:     app.getSingleIntQueryParameter(query, "page", 1, v),
                PageSize: app.getSingleIntQueryParameter(query, "page_size", 20, v),
                Sort:     app.getSingleQueryParameter(query, "sort", "last_name"),
                SortSafelist: []string{
                        "id", "first_name", "last_name", "email", "created_at",
                        "-id", "-first_name", "-last_name", "-email", "-created_at",
                },
        }

        data.ValidateFilters(v, filters)

        isActivated := app.getOptionalBoolQueryParameter(query, "is_activated", v)
        isFacilitator := app.getOptionalBoolQueryParameter(query, "is_facilitator", v)
        isOfficer := app.getOptionalBoolQueryParameter(query, "is_officer", v)
        isDeleted := app.getOptionalBoolQueryParameter(query, "is_deleted", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">users, metadata, err := app.models.User.GetAll(
                app.getSingleQueryParameter(query, "first_name", ""),
                app.getSingleQueryParameter(query, "last_name", ""),
                app.getSingleQueryParameter(query, "email", ""),
                app.getSingleQueryParameter(query, "gender", ""),
                isActivated, isFacilitator, isOfficer, isDeleted,
                filters,
        )
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">payload := envelope{
                "users":    users,
                "metadata": metadata,
        }

        if err := app.writeJSON(w, http.StatusOK, payload, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateUserHandler performs a partial update on a user record.
//
//        @Summary                Update a user
//        @Description        Perform a partial update on a user record
//        @Tags                        users
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "User ID"
//        @Success                200        {object}        envelope
//        @Failure                400        {object}        errorResponse
//        @Failure                422        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/users/{id} [patch]
func (app *appDependencies) updateUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                FirstName     *string `json:"first_name"`
                LastName      *string `json:"last_name"`
                Email         *string `json:"email"`
                Gender        *string `json:"gender"`
                Password      *string `json:"password"`
                IsFacilitator *bool   `json:"is_facilitator"`
                IsActivated   *bool   `json:"is_activated"`
                IsOfficer     *bool   `json:"is_officer"`
                Version       int     `json:"version"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if input.Version == 0 || input.Version != user.Version </span><span class="cov8" title="1">{
                app.editConflictResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">if input.FirstName != nil </span><span class="cov8" title="1">{
                user.FirstName = *input.FirstName
        }</span>
        <span class="cov8" title="1">if input.LastName != nil </span><span class="cov8" title="1">{
                user.LastName = *input.LastName
        }</span>
        <span class="cov8" title="1">if input.Email != nil </span><span class="cov0" title="0">{
                user.Email = *input.Email
        }</span>
        <span class="cov8" title="1">if input.Gender != nil </span><span class="cov0" title="0">{
                user.Gender = *input.Gender
        }</span>
        <span class="cov8" title="1">if input.Password != nil </span><span class="cov0" title="0">{
                if err := user.Password.Set(*input.Password); err != nil </span><span class="cov0" title="0">{
                        app.serverErrorResponse(w, r, err)
                        return
                }</span>
        }
        <span class="cov8" title="1">if input.IsFacilitator != nil </span><span class="cov0" title="0">{
                user.IsFacilitator = *input.IsFacilitator
        }</span>
        <span class="cov8" title="1">if input.IsActivated != nil </span><span class="cov0" title="0">{
                user.IsActivated = *input.IsActivated
        }</span>
        <span class="cov8" title="1">if input.IsOfficer != nil </span><span class="cov0" title="0">{
                user.IsOfficer = *input.IsOfficer
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateUser(v, user)
        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.User.Update(user); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">payload := envelope{"user": user}

        if err := app.writeJSON(w, http.StatusOK, payload, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updatePasswordHandler updates a user's password.
func (app *appDependencies) updatePasswordHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">user, err := app.models.User.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                Password string `json:"password"`
        }

        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if err := user.Password.Set(input.Password); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateUser(v, user)
        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">if err := app.models.User.Update(user); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrEditConflict):<span class="cov0" title="0">
                        app.editConflictResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">payload := envelope{"user": user}

        if err := app.writeJSON(w, http.StatusOK, payload, nil); err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// deleteUserHandler deletes a user record.
//
//        @Summary                Delete a user
//        @Description        Delete a user record by ID
//        @Tags                        users
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        id        path                int        true        "User ID"
//        @Success                200        {object}        envelope{message=string}
//        @Failure                404        {object}        errorResponse
//        @Failure                500        {object}        errorResponse
//        @Router                        /v1/users/{id} [delete]
func (app *appDependencies) deleteUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.User.SoftDelete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">app.writeJSON(w, http.StatusOK, envelope{"message": "user successfully deactivated"}, nil)</span>
}

// restoreUserHandler restores a soft-deleted user record.
func (app *appDependencies) restoreUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.User.Restore(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">app.writeJSON(w, http.StatusOK, envelope{"message": "user successfully restored"}, nil)</span>
}

// Permanently delete a user record.
func (app *appDependencies) hardDeleteUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.User.HardDelete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">app.writeJSON(w, http.StatusOK, envelope{"message": "user successfully deleted"}, nil)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/Pedro-J-Kukul/police_training/internal/data"
        "github.com/Pedro-J-Kukul/police_training/internal/validator"
)

// @Summary Create a workshop
// @Description Create a new workshop
// @Tags workshops
// @Accept json
// @Produce json
// @Param workshop body map[string]interface{} true "Workshop data (workshop_name, category_id, type_id, credit_hours, description, is_active)"
// @Success 201 {object} map[string]interface{} "Created workshop envelope {\"workshop\": {...}}"
// @Failure 400 {object} map[string]string "Bad request"
// @Failure 422 {object} map[string]interface{} "Validation errors"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /v1/workshops [post]
func (app *appDependencies) createWorkshopHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                WorkshopName string  `json:"workshop_name"`
                CategoryID   int64   `json:"category_id"`
                TypeID       int64   `json:"type_id"`
                CreditHours  int     `json:"credit_hours"`
                Description  *string `json:"description"`
                IsActive     *bool   `json:"is_active"`
        }

        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">workshop := &amp;data.Workshop{
                WorkshopName: input.WorkshopName,
                CategoryID:   input.CategoryID,
                TypeID:       input.TypeID,
                CreditHours:  input.CreditHours,
                Description:  input.Description,
                IsActive:     true, // default
        }

        if input.IsActive != nil </span><span class="cov8" title="1">{
                workshop.IsActive = *input.IsActive
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateWorkshop(v, workshop)

        if !v.IsEmpty() </span><span class="cov8" title="1">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.Workshop.Insert(workshop)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov8" title="1">
                        app.conflictResponse(w, r) // Change from failedValidationResponse to conflictResponse
                        return</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov8" title="1">
                        app.badRequestResponse(w, r, errors.New("invalid category_id or type_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">headers := make(http.Header)
        headers.Set("Location", fmt.Sprintf("/v1/workshops/%d", workshop.ID))

        err = app.writeJSON(w, http.StatusCreated, envelope{"workshop": workshop}, headers)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// @Summary Get a workshop
// @Description Retrieve a workshop by ID
// @Tags workshops
// @Accept json
// @Produce json
// @Param id path int true "Workshop ID"
// @Success 200 {object} map[string]interface{} "Workshop envelope {\"workshop\": {...}}"
// @Failure 404 {object} map[string]string "Not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /v1/workshops/{id} [get]
func (app *appDependencies) showWorkshopHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov8" title="1">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">workshop, err := app.models.Workshop.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"workshop": workshop}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) listWorkshopsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        v := validator.New()

        filters := app.readFilters(query, "workshop_name", 20, []string{"workshop_name", "-workshop_name", "id", "-id", "credit_hours", "-credit_hours", "created_at", "-created_at"}, v)

        name := likeSearch(app.getSingleQueryParameter(query, "workshop_name", ""))
        categoryID := app.getOptionalInt64QueryParameter(query, "category_id", v)
        typeID := app.getOptionalInt64QueryParameter(query, "type_id", v)
        isActive := app.getOptionalBoolQueryParameter(query, "is_active", v)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">workshops, metadata, err := app.models.Workshop.GetAll(name, categoryID, typeID, isActive, filters)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"workshops": workshops, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) updateWorkshopHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">workshop, err := app.models.Workshop.Get(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var input struct {
                WorkshopName *string `json:"workshop_name"`
                CategoryID   *int64  `json:"category_id"`
                TypeID       *int64  `json:"type_id"`
                CreditHours  *int    `json:"credit_hours"`
                Description  *string `json:"description"`
                IsActive     *bool   `json:"is_active"`
        }

        err = app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">if input.WorkshopName != nil </span><span class="cov8" title="1">{
                workshop.WorkshopName = *input.WorkshopName
        }</span>
        <span class="cov8" title="1">if input.CategoryID != nil </span><span class="cov8" title="1">{
                workshop.CategoryID = *input.CategoryID
        }</span>
        <span class="cov8" title="1">if input.TypeID != nil </span><span class="cov0" title="0">{
                workshop.TypeID = *input.TypeID
        }</span>
        <span class="cov8" title="1">if input.CreditHours != nil </span><span class="cov8" title="1">{
                workshop.CreditHours = *input.CreditHours
        }</span>
        <span class="cov8" title="1">if input.Description != nil </span><span class="cov8" title="1">{
                workshop.Description = input.Description
        }</span>
        <span class="cov8" title="1">if input.IsActive != nil </span><span class="cov0" title="0">{
                workshop.IsActive = *input.IsActive
        }</span>

        <span class="cov8" title="1">v := validator.New()
        data.ValidateWorkshop(v, workshop)

        if !v.IsEmpty() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.Workshop.Update(workshop)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case errors.Is(err, data.ErrDuplicateValue):<span class="cov8" title="1">
                        app.conflictResponse(w, r) // Change from failedValidationResponse to conflictResponse
                        return</span>
                case errors.Is(err, data.ErrForeignKeyViolation):<span class="cov8" title="1">
                        app.badRequestResponse(w, r, errors.New("invalid category_id or type_id"))</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"workshop": workshop}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

func (app *appDependencies) deleteWorkshopHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := app.readIDParameter(r)
        if err != nil </span><span class="cov0" title="0">{
                app.notFoundResponse(w, r)
                return
        }</span>

        <span class="cov8" title="1">err = app.models.Workshop.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, data.ErrRecordNotFound):<span class="cov8" title="1">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = app.writeJSON(w, http.StatusOK, envelope{"message": "workshop successfully deleted"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
